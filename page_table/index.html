<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>Linux ARM64 `__create_pgd_mapping` 分析</title>
<meta name="google-site-verification" content="CmjL_aZ8fDb2ZxqOct5raymSCyinEt7dd7JeIro6eig" />
<meta name="keywords" content="Linux ARM64 `__create_pgd_mapping` 分析, blog keywords">
<meta name="description" content="
Linux版本：v6.0
處理器架構：ARMv8

前言在理解 Linux kernel 開機流程時，最難理解的應該就是記憶體映射的部份了，我認為困難的點在於處理記憶體映射的程式本身也在記憶體的映射之中，所以除了看懂程式邏輯之外，還必須理">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>





  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://rhythm16.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://rhythm16.github.io">
        <h1 class="site-title">rhythm16.github.io</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        Home
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        Categories
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        Archives
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Linux ARM64 `__create_pgd_mapping` 分析</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-01-17</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/page-tables/">
              page tables
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>Linux版本：v6.0</p>
<p>處理器架構：ARMv8</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在理解 Linux kernel 開機流程時，最難理解的應該就是記憶體映射的部份了，我認為困難的點在於處理記憶體映射的程式本身也在記憶體的映射之中，所以除了看懂程式邏輯之外，還必須理解該部份程式是在怎樣的映射環境中執行，以及他的操作會對記憶體影射造成什麼樣的影響等等。再加上變數中存的位址有些是虛擬位址有些是實體位址，更把事情給複雜化。</p>
<p>這篇介紹<code>__create_pgd_mapping</code> ，負責在開機階段建立各級頁表，主要著重在實作的分析，使用場景則先略過。</p>
<h2 id="create-pgd-mapping-執行環境"><a href="#create-pgd-mapping-執行環境" class="headerlink" title="__create_pgd_mapping 執行環境"></a><code>__create_pgd_mapping</code> 執行環境</h2><p>在說明函式原型及實作之前，先說明一下執行環境，<code>__create_pgd_mapping</code> 是開機流程所使用的工具函式，記憶體的映射狀況為MMU已開啟，使用的pgd(大部分)為<code>init_pg_dir</code> ，linear mapping有可能尚未建立所以無法使用，fixmap除了level 3以外的頁表已經建立好，kernel跑在高虛擬位址。</p>
<h2 id="create-pgd-mapping-函式原型"><a href="#create-pgd-mapping-函式原型" class="headerlink" title="__create_pgd_mapping 函式原型"></a><code>__create_pgd_mapping</code> 函式原型</h2><p>以下是<code>__create_pgd_mapping</code> 的函式原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __create_pgd_mapping(<span class="type">pgd_t</span> *pgdir, <span class="type">phys_addr_t</span> phys,</span><br><span class="line">                                 <span class="type">unsigned</span> <span class="type">long</span> virt, <span class="type">phys_addr_t</span> size,</span><br><span class="line">                                 <span class="type">pgprot_t</span> prot,</span><br><span class="line">                                 <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span><br><span class="line">                                 <span class="type">int</span> flags);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>pgdir</code> : 想要建立映射的頁表的根(虛擬位址)</p>
</li>
<li><p><code>phys</code> : 建立映射的物理位址起始位址</p>
</li>
<li><p><code>virt</code> : 建立映射的虛擬位址起始位址</p>
</li>
<li><p><code>size</code> : 映射的大小</p>
</li>
<li><p><code>prot</code> : 映射的屬性</p>
</li>
<li><p><code>pgtable_alloc</code> : 建立頁表過程中，使用的記憶體分配函式</p>
</li>
<li><p><code>flags</code> : 一些決定建立頁表過程行為的選項</p>
</li>
</ul>
<h2 id="create-pgd-mapping-實作"><a href="#create-pgd-mapping-實作" class="headerlink" title="__create_pgd_mapping 實作"></a><code>__create_pgd_mapping</code> 實作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __create_pgd_mapping(<span class="type">pgd_t</span> *pgdir, <span class="type">phys_addr_t</span> phys,</span><br><span class="line">                                 <span class="type">unsigned</span> <span class="type">long</span> virt, <span class="type">phys_addr_t</span> size,</span><br><span class="line">                                 <span class="type">pgprot_t</span> prot,</span><br><span class="line">                                 <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span><br><span class="line">                                 <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">        mutex_lock(&amp;fixmap_lock);</span><br><span class="line">        __create_pgd_mapping_locked(pgdir, phys, virt, size, prot,</span><br><span class="line">                                    pgtable_alloc, flags);</span><br><span class="line">        mutex_unlock(&amp;fixmap_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>沒什麼好講的，取fixmap lock然後呼叫內部<code>__create_pgd_mapping_locked</code></p>
<h3 id="create-pgd-mapping-locked"><a href="#create-pgd-mapping-locked" class="headerlink" title="__create_pgd_mapping_locked"></a><code>__create_pgd_mapping_locked</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __create_pgd_mapping_locked(<span class="type">pgd_t</span> *pgdir, <span class="type">phys_addr_t</span> phys,</span><br><span class="line">                                        <span class="type">unsigned</span> <span class="type">long</span> virt, <span class="type">phys_addr_t</span> size,</span><br><span class="line">                                        <span class="type">pgprot_t</span> prot,</span><br><span class="line">                                        <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span><br><span class="line">                                        <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> addr, end, next;</span><br><span class="line">        <span class="comment">// 計算轉換virt所用的pgd entry的位址</span></span><br><span class="line">        <span class="type">pgd_t</span> *pgdp = pgd_offset_pgd(pgdir, virt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the virtual and physical address don&#x27;t have the same offset</span></span><br><span class="line"><span class="comment">         * within a page, we cannot map the region as the caller expects.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 由於頁表轉換是以頁為單位，若phys和virt在頁中的offset不一樣則無法建立映射</span></span><br><span class="line">        <span class="keyword">if</span> (WARN_ON((phys ^ virt) &amp; ~PAGE_MASK))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 使phys向下對齊頁</span></span><br><span class="line">        phys &amp;= PAGE_MASK;</span><br><span class="line">        <span class="comment">// addr為局部變數，紀錄目前要建立映射的虛擬位址，初始化為virt向下對齊頁</span></span><br><span class="line">        addr = virt &amp; PAGE_MASK;</span><br><span class="line">        <span class="comment">// end紀錄映射結束的虛擬位址，virt + size向上對齊頁</span></span><br><span class="line">        end = PAGE_ALIGN(virt + size);</span><br><span class="line">        <span class="comment">// 這個迴圈一次建立一個pgd entry範圍的映射，若以48bits,4K頁為例就是2^39,</span></span><br><span class="line">        <span class="comment">// 512GB的區間</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// pgd_addr_end回傳(addr + 一個pgd entry的映射範圍)，或end，</span></span><br><span class="line">                <span class="comment">// 看哪個比較小</span></span><br><span class="line">                next = pgd_addr_end(addr, end);</span><br><span class="line">                <span class="comment">// 把當前pgdp，</span></span><br><span class="line">                <span class="comment">// addr(這個iteration要建立映射的虛擬位址的開頭)</span></span><br><span class="line">                <span class="comment">// next(這個iteration要建立映射的虛擬位址結尾)</span></span><br><span class="line">                <span class="comment">// phys(這個iteration要建立映射的物理位址開頭)</span></span><br><span class="line">                <span class="comment">// prot, pgtable_alloc, flag傳入處理pud層級的函式</span></span><br><span class="line">                alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc,</span><br><span class="line">                               flags);</span><br><span class="line">                <span class="comment">// alloc_init_pud建立addr~next的映射，所以return後把phys</span></span><br><span class="line">                <span class="comment">// 往前推進next - addr</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// 換下一個pgd entry，也推進addr，如果addr == end則結束</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pgdp++, addr = next, addr != end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="alloc-init-pud"><a href="#alloc-init-pud" class="headerlink" title="alloc_init_pud"></a><code>alloc_init_pud</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_init_pud</span><span class="params">(<span class="type">pgd_t</span> *pgdp, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> end,</span></span><br><span class="line"><span class="params">                           <span class="type">phys_addr_t</span> phys, <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                           <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="type">pud_t</span> *pudp;</span><br><span class="line">        <span class="comment">// p4d是如果要使用五層頁表才有的層級，四層以下p4dp = pgdp，目前假設四層頁表</span></span><br><span class="line">        <span class="type">p4d_t</span> *p4dp = p4d_offset(pgdp, addr);</span><br><span class="line">        <span class="comment">// 這邊假設p4d = pgd</span></span><br><span class="line">        <span class="type">p4d_t</span> p4d = READ_ONCE(*p4dp);</span><br><span class="line">        <span class="comment">// 如果pgdp指到的entry是none</span></span><br><span class="line">        <span class="keyword">if</span> (p4d_none(p4d)) &#123;</span><br><span class="line">                <span class="comment">// 設定這個entry要指到table(指到pud)，且EL0不能執行</span></span><br><span class="line">                <span class="type">p4dval_t</span> p4dval = P4D_TYPE_TABLE | P4D_TABLE_UXN;</span><br><span class="line">                <span class="type">phys_addr_t</span> pud_phys;</span><br><span class="line">                <span class="comment">// 如果flags有NO_EXEC_MAPPING</span></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; NO_EXEC_MAPPINGS)</span><br><span class="line">                        <span class="comment">// 則EL1也不能執行</span></span><br><span class="line">                        p4dval |= P4D_TABLE_PXN;</span><br><span class="line">                BUG_ON(!pgtable_alloc);</span><br><span class="line">                <span class="comment">// 用傳進來的函式分配一個pud頁</span></span><br><span class="line">                pud_phys = pgtable_alloc(PUD_SHIFT);</span><br><span class="line">                <span class="comment">// 用pud頁的物理位址和p4dval製作成pgd entry存進pgdp</span></span><br><span class="line">                __p4d_populate(p4dp, pud_phys, p4dval);</span><br><span class="line">                <span class="comment">// 讀出來檢查</span></span><br><span class="line">                p4d = READ_ONCE(*p4dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 這裡的p4d必須要是正常的pgd entry值</span></span><br><span class="line">        BUG_ON(p4d_bad(p4d));</span><br><span class="line">        <span class="comment">// 這行有點tricky，它負責把pud頁map到一個固定的虛擬位址上，為什麼要這樣做呢？</span></span><br><span class="line">        <span class="comment">// 因為執行到這邊的時候我們從pgdp讀出一個entry，裡頭有pud頁的物理位址，而要存取pud頁</span></span><br><span class="line">        <span class="comment">// 只有物理位址是不行的，要把pud頁map到虛擬位址上程式才能存取它，所以使用fixmap</span></span><br><span class="line">        <span class="comment">// 機制來把pud頁map到一個已知的虛擬位址，接下來就可以操作這個pud頁了</span></span><br><span class="line">        <span class="comment">// pudp = 轉換addr所使用的pud entry的虛擬位址</span></span><br><span class="line">        pudp = pud_set_fixmap_offset(p4dp, addr);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 讀取pud entry</span></span><br><span class="line">                <span class="type">pud_t</span> old_pud = READ_ONCE(*pudp);</span><br><span class="line">                <span class="comment">// next = ((addr + 一個pud entry的映射範圍)，或end，看哪個小)</span></span><br><span class="line">                next = pud_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * For 4K granule only, attempt to put down a 1GB block</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 如果可以使用section mapping (一次map 1GB)</span></span><br><span class="line">                <span class="keyword">if</span> (pud_sect_supported() &amp;&amp;</span><br><span class="line">                   <span class="comment">// 而且目前要map的範圍(addr~next)和物理位址phys都對齊1GB</span></span><br><span class="line">                   ((addr | next | phys) &amp; ~PUD_MASK) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    <span class="comment">// 而且flags沒說不能用section(block) mapping</span></span><br><span class="line">                    (flags &amp; NO_BLOCK_MAPPINGS) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 在這個層級直接map一個1GB的頁</span></span><br><span class="line">                        pud_set_huge(pudp, phys, prot);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * After the PUD entry has been populated once, we</span></span><br><span class="line"><span class="comment">                         * only allow updates to the permission attributes.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="comment">// 檢查，跳過</span></span><br><span class="line">                        BUG_ON(!pgattr_change_is_safe(pud_val(old_pud),</span><br><span class="line">                                                      READ_ONCE(pud_val(*pudp))));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// pudp: 當前pud entry的虛擬位址</span></span><br><span class="line">                        <span class="comment">// addr: 當前要map的虛擬位址起始</span></span><br><span class="line">                        <span class="comment">// next: 當前要map的虛擬位址終點</span></span><br><span class="line">                        <span class="comment">// phys: 當前要map的物理位址</span></span><br><span class="line">                        <span class="comment">// alloc_init_cont_pmd負責map addr~next</span></span><br><span class="line">                        alloc_init_cont_pmd(pudp, addr, next, phys, prot,</span><br><span class="line">                                            pgtable_alloc, flags);</span><br><span class="line">                        BUG_ON(pud_val(old_pud) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                               pud_val(old_pud) != READ_ONCE(pud_val(*pudp)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// alloc_init_cont_pmd建立addr~next的映射，所以return後把phys</span></span><br><span class="line">                <span class="comment">// 往前推進next - addr</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// 換下一個pud entry，也推進addr，如果addr == end則結束</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pudp++, addr = next, addr != end);</span><br><span class="line">        <span class="comment">// 把剛剛map的pud頁解除映射</span></span><br><span class="line">        pud_clear_fixmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到這邊要來解釋一下函式邏輯，目前看到的call chain長這樣：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__create_pgd_mapping</span><br><span class="line">--&gt; __create_pgd_mapping_locked</span><br><span class="line">    --&gt; alloc_init_pud</span><br><span class="line">        // 以下下面會說明</span><br><span class="line">        --&gt; alloc_init_cont_pmd</span><br><span class="line">            --&gt; init_pmd</span><br><span class="line">                --&gt; alloc_init_cont_pte</span><br><span class="line">                    --&gt; init_pte </span><br></pre></td></tr></table></figure>

<p>上面分析說明了：</p>
<p><code>__create_pgd_mapping_locked</code> 負責填充pgd頁</p>
<p><code>alloc_init_pud</code> 負責填充pud頁</p>
<p>那為什麼pmd頁和pte頁各需要兩個函數來處理呢？原因是ARMv8架構中頁表項有個contiguous bit，簡單來說如果一段連續的虛擬位址會經過頁表轉換出另一段連續的物理位址，軟體可以設置這個bit來優化TLB的表現，<code>alloc_init_cont_pmd</code> 和 <code>alloc_init_cont_pte</code> 盡量把傳入的位址範圍使用contiguous bit來建立mapping，而<code>init_pmd</code> 和<code>init_pte</code> 負責實際的pmd頁和pte頁。</p>
<h3 id="alloc-init-cont-pmd"><a href="#alloc-init-cont-pmd" class="headerlink" title="alloc_init_cont_pmd"></a><code>alloc_init_cont_pmd</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_init_cont_pmd</span><span class="params">(<span class="type">pud_t</span> *pudp, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">long</span> end, <span class="type">phys_addr_t</span> phys,</span></span><br><span class="line"><span class="params">                                <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                                <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>), <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="comment">// 讀取傳入的pudp</span></span><br><span class="line">        <span class="type">pud_t</span> pud = READ_ONCE(*pudp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Check for initial section mappings in the pgd/pud.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// pud entry如果是section mapping的話就不會呼叫到我們了，所以代表出錯</span></span><br><span class="line">        BUG_ON(pud_sect(pud));</span><br><span class="line">        <span class="comment">// 如果這個entry還沒建立</span></span><br><span class="line">        <span class="keyword">if</span> (pud_none(pud)) &#123;</span><br><span class="line">                <span class="comment">// 設定這個entry要指到table(指到pmd)，且EL0不能執行</span></span><br><span class="line">                <span class="type">pudval_t</span> pudval = PUD_TYPE_TABLE | PUD_TABLE_UXN;</span><br><span class="line">                <span class="type">phys_addr_t</span> pmd_phys;</span><br><span class="line">                <span class="comment">// 如果flags有NO_EXEC_MAPPING</span></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; NO_EXEC_MAPPINGS)</span><br><span class="line">                        <span class="comment">// 則EL1也不能執行</span></span><br><span class="line">                        pudval |= PUD_TABLE_PXN;</span><br><span class="line">                BUG_ON(!pgtable_alloc);</span><br><span class="line">                <span class="comment">// 用傳進來的函式分配一個pmd頁</span></span><br><span class="line">                pmd_phys = pgtable_alloc(PMD_SHIFT);</span><br><span class="line">                <span class="comment">// 用pmd頁的物理位址和pudval製作成pud entry存進pudp</span></span><br><span class="line">                __pud_populate(pudp, pmd_phys, pudval);</span><br><span class="line">                <span class="comment">// 讀出來檢查</span></span><br><span class="line">                pud = READ_ONCE(*pudp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 這裡的pud必須要是正常的pud entry值</span></span><br><span class="line">        BUG_ON(pud_bad(pud));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">pgprot_t</span> __prot = prot;</span><br><span class="line">                <span class="comment">// next = ((addr + 一個pmd entry的映射範圍)，或end，看哪個小)</span></span><br><span class="line">                next = pmd_cont_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* use a contiguous mapping if the range is suitably aligned */</span></span><br><span class="line">                <span class="comment">// 如果addr, next, phys都對齊使用contiguous( bit) mapping的要求</span></span><br><span class="line">                <span class="comment">// e.g. 32MB</span></span><br><span class="line">                <span class="keyword">if</span> ((((addr | next | phys) &amp; ~CONT_PMD_MASK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 而且flags沒說不能用contiguous mapping</span></span><br><span class="line">                    (flags &amp; NO_CONT_MAPPINGS) == <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">// entry attributes加上contiguous bit</span></span><br><span class="line">                        __prot = __pgprot(pgprot_val(prot) | PTE_CONT);</span><br><span class="line">                <span class="comment">// 進入處理pmd頁的函式</span></span><br><span class="line">                init_pmd(pudp, addr, next, phys, __prot, pgtable_alloc, flags);</span><br><span class="line">                <span class="comment">// init_pmd建立addr~next的映射，所以return後把phys</span></span><br><span class="line">                <span class="comment">// 往前推進next - addr</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// 推進addr，如果addr == end則結束</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (addr = next, addr != end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="init-pmd"><a href="#init-pmd" class="headerlink" title="init_pmd"></a><code>init_pmd</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pmd</span><span class="params">(<span class="type">pud_t</span> *pudp, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> end,</span></span><br><span class="line"><span class="params">                     <span class="type">phys_addr_t</span> phys, <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                     <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>), <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="type">pmd_t</span> *pmdp;</span><br><span class="line">        <span class="comment">// 和前面pud_set_fixmap_offset的操作一樣，從pudp讀取pmd的物理位址，並把物理頁</span></span><br><span class="line">        <span class="comment">// map到一個特定的虛擬位址並回傳addr所使用的pmd entry的位址</span></span><br><span class="line">        pmdp = pmd_set_fixmap_offset(pudp, addr);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 讀取pmd entry</span></span><br><span class="line">                <span class="type">pmd_t</span> old_pmd = READ_ONCE(*pmdp);</span><br><span class="line">                <span class="comment">// next = ((addr + 一個pmd entry的映射範圍)，或end，看哪個小)</span></span><br><span class="line">                next = pmd_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* try section mapping first */</span></span><br><span class="line">                <span class="comment">// 如果addr, next, phys都對齊一個pmd section映射大小(通常是2MB)</span></span><br><span class="line">                <span class="keyword">if</span> (((addr | next | phys) &amp; ~PMD_MASK) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    <span class="comment">// 而且flags沒說不能用section(block) mapping</span></span><br><span class="line">                    (flags &amp; NO_BLOCK_MAPPINGS) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 在這個層級直接map一個大頁(通常是2MB)</span></span><br><span class="line">                        pmd_set_huge(pmdp, phys, prot);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * After the PMD entry has been populated once, we</span></span><br><span class="line"><span class="comment">                         * only allow updates to the permission attributes.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        BUG_ON(!pgattr_change_is_safe(pmd_val(old_pmd),</span><br><span class="line">                                                      READ_ONCE(pmd_val(*pmdp))));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 進行contiguous pte的操作</span></span><br><span class="line">                        alloc_init_cont_pte(pmdp, addr, next, phys, prot,</span><br><span class="line">                                            pgtable_alloc, flags);</span><br><span class="line"></span><br><span class="line">                        BUG_ON(pmd_val(old_pmd) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                               pmd_val(old_pmd) != READ_ONCE(pmd_val(*pmdp)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// alloc_init_cont_pte建立addr~next的映射，所以return後把phys</span></span><br><span class="line">                <span class="comment">// 往前推進next - addr</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// 換下一個pmd entry，也推進addr，如果addr == end則結束</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pmdp++, addr = next, addr != end);</span><br><span class="line">        <span class="comment">// 把剛剛map的pmd頁解除映射</span></span><br><span class="line">        pmd_clear_fixmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下來<code>alloc_init_cont_pte</code> 和<code>init_pte</code> 的操作邏輯跟pmd基本一樣，可以自己研究看看：</p>
<h3 id="alloc-init-cont-pte"><a href="#alloc-init-cont-pte" class="headerlink" title="alloc_init_cont_pte"></a><code>alloc_init_cont_pte</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_init_cont_pte</span><span class="params">(<span class="type">pmd_t</span> *pmdp, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">long</span> end, <span class="type">phys_addr_t</span> phys,</span></span><br><span class="line"><span class="params">                                <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                                <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="type">pmd_t</span> pmd = READ_ONCE(*pmdp);</span><br><span class="line"></span><br><span class="line">        BUG_ON(pmd_sect(pmd));</span><br><span class="line">        <span class="keyword">if</span> (pmd_none(pmd)) &#123;</span><br><span class="line">                <span class="type">pmdval_t</span> pmdval = PMD_TYPE_TABLE | PMD_TABLE_UXN;                                                                                                       </span><br><span class="line">                <span class="type">phys_addr_t</span> pte_phys;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; NO_EXEC_MAPPINGS)</span><br><span class="line">                        pmdval |= PMD_TABLE_PXN;</span><br><span class="line">                BUG_ON(!pgtable_alloc);</span><br><span class="line">                pte_phys = pgtable_alloc(PAGE_SHIFT);</span><br><span class="line">                __pmd_populate(pmdp, pte_phys, pmdval);</span><br><span class="line">                pmd = READ_ONCE(*pmdp);</span><br><span class="line">        &#125;</span><br><span class="line">        BUG_ON(pmd_bad(pmd));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">pgprot_t</span> __prot = prot;</span><br><span class="line"></span><br><span class="line">                next = pte_cont_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* use a contiguous mapping if the range is suitably aligned */</span></span><br><span class="line">                <span class="keyword">if</span> ((((addr | next | phys) &amp; ~CONT_PTE_MASK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                    (flags &amp; NO_CONT_MAPPINGS) == <span class="number">0</span>)</span><br><span class="line">                        __prot = __pgprot(pgprot_val(prot) | PTE_CONT);</span><br><span class="line"></span><br><span class="line">                init_pte(pmdp, addr, next, phys, __prot);</span><br><span class="line"></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        &#125; <span class="keyword">while</span> (addr = next, addr != end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="init-pte"><a href="#init-pte" class="headerlink" title="init_pte"></a><code>init_pte</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pte</span><span class="params">(<span class="type">pmd_t</span> *pmdp, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> end,</span></span><br><span class="line"><span class="params">                     <span class="type">phys_addr_t</span> phys, <span class="type">pgprot_t</span> prot)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pte_t</span> *ptep;</span><br><span class="line"></span><br><span class="line">        ptep = pte_set_fixmap_offset(pmdp, addr);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">pte_t</span> old_pte = READ_ONCE(*ptep);</span><br><span class="line">                <span class="comment">// 這行真正把phys和prot組合成pte entry，寫進ptep指向的地方</span></span><br><span class="line">                <span class="comment">// 完成一個頁最終的頁表映射</span></span><br><span class="line">                set_pte(ptep, pfn_pte(__phys_to_pfn(phys), prot));</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * After the PTE entry has been populated once, we</span></span><br><span class="line"><span class="comment">                 * only allow updates to the permission attributes.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                BUG_ON(!pgattr_change_is_safe(pte_val(old_pte),</span><br><span class="line">                                              READ_ONCE(pte_val(*ptep))));</span><br><span class="line"></span><br><span class="line">                phys += PAGE_SIZE;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ptep++, addr += PAGE_SIZE, addr != end);</span><br><span class="line"></span><br><span class="line">        pte_clear_fixmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%89%8D%E8%A8%80"><span class="top-box-text">前言</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#create-pgd-mapping-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83"><span class="top-box-text">__create_pgd_mapping 執行環境</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#create-pgd-mapping-%E5%87%BD%E5%BC%8F%E5%8E%9F%E5%9E%8B"><span class="top-box-text">__create_pgd_mapping 函式原型</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#create-pgd-mapping-%E5%AF%A6%E4%BD%9C"><span class="top-box-text">__create_pgd_mapping 實作</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#create-pgd-mapping-locked"><span class="top-box-text">__create_pgd_mapping_locked</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#alloc-init-pud"><span class="top-box-text">alloc_init_pud</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#alloc-init-cont-pmd"><span class="top-box-text">alloc_init_cont_pmd</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#init-pmd"><span class="top-box-text">init_pmd</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#alloc-init-cont-pte"><span class="top-box-text">alloc_init_cont_pte</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#init-pte"><span class="top-box-text">init_pte</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/kaslr_en/">
          <h3 class="post-title">
            Next: Linux ARM64 KASLR Implementation(1): Kernel Image Randomization
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

