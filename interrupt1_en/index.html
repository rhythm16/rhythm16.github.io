<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>Linux Interrupt Subsystem Intro(1): Interrupt Handling Initialization</title>
<meta name="google-site-verification" content="CmjL_aZ8fDb2ZxqOct5raymSCyinEt7dd7JeIro6eig" />
<meta name="keywords" content="Linux Interrupt Subsystem Intro(1): Interrupt Handling Initialization, blog keywords">
<meta name="description" content="
Linux version: v6.0
Architecture: ARMv8

I have been digging into the details of interrupt processing in Linux in the p">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>





  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://rhythm16.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://rhythm16.github.io">
        <h1 class="site-title">rhythm16.github.io</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        Home
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        Categories
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        Archives
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Linux Interrupt Subsystem Intro(1): Interrupt Handling Initialization</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-12-27</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/interrupt/">
              interrupt
                
                  ，
                
              </a>
            
              <a href="/tags/ARMv8/">
              ARMv8
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>Linux version: v6.0</p>
<p>Architecture: ARMv8</p>
</blockquote>
<p>I have been digging into the details of interrupt processing in Linux in the past few weeks. Although there are quite some quality articles and videos explaining the interrupt subsystem that can be found on the internet, personally it felt hard to get the big picture. Only after I actually traced the code that everything came together. In this post I hope to give an overview of the interrupt architecture by quickly going through how Linux sets up and processes interrupts. First some concepts around interrupt processing is introduced, then a real example is given to show how the code works.</p>
<p>The example shown here is the ARM64 architecture with a GICv2 interrupt controller, setting up the IPI interrupt. To avoid the discussion from becoming too long and digressing, the explanation is going to be pretty specific to our example, hence some details would be omitted. There are a couple of related concepts at the end of the article for the interested readers to reference.</p>
<blockquote>
<p>The post became quite long as I progressed, so I decided to split it into two articles:</p>
<p>“Interrupt Handling Initialization” and “Interrupt Handling Process”.</p>
</blockquote>
<h2 id="Quick-Intro-to-OS-Interrupts"><a href="#Quick-Intro-to-OS-Interrupts" class="headerlink" title="Quick Intro to OS Interrupts"></a>Quick Intro to OS Interrupts</h2><p>Needless to say, knowing that an interrupt is is necessary to understanding how Linux processes them. At a fundamental level, interrupts are just the outside world changing a CPU’s pin’s voltage. After this change of voltage, the internal circuit of the CPU detects and reacts to this change. In a modern computer, there are many peripheral devices that each need to interrupt the CPU to signal some events, or request some computation, e.g. the NIC receiving and transmitting packets, keyboard input, IPI’s, etc. An <em>Interrupt Controller</em> is the piece of hardware that helps manage these interrupts, typically CPUs can manage interrupts through the interrupt controller to:</p>
<ul>
<li><p>enable and disable each interrupt</p>
</li>
<li><p>set the destination CPU of each interrupt (CPU affinity)</p>
</li>
<li><p>set priorities of interrupts</p>
</li>
<li><p>invoke a software interrupt</p>
</li>
</ul>
<p>etc.</p>
<p>The CPU also communicates with the interrupt controller when processing interrupts, following is a typical series of steps involved in processing an interrupt:</p>
<ol>
<li><p>The interrupt controller detects that peripheral device number 21 wishes to interrupt the CPU</p>
</li>
<li><p>The interrupt controller observes that device 21’s interrupt is set to be delivered to CPU 0</p>
</li>
<li><p>The interrupt controller writes the number “21” into the register corresponding to the current interrupt (this register is within the interrupt controller, not the CPU)</p>
</li>
<li><p>The interrupt controller changes the pin’s voltage connected to CPU 0 to inform an interrupt had arrived</p>
</li>
<li><p>CPU0 handles interrupt for device 21</p>
</li>
<li><p>After interrupt handling completion, CPU 0 writes to the EOI (End-Of-Interrupt) register in the interrupt controller, to inform the interrupt controller that it had completed handling the current interrupt</p>
</li>
</ol>
<h2 id="Interrupt-Management-and-Data-Structures-used-in-the-Linux-Kernel"><a href="#Interrupt-Management-and-Data-Structures-used-in-the-Linux-Kernel" class="headerlink" title="Interrupt Management and Data Structures used in the Linux Kernel"></a>Interrupt Management and Data Structures used in the Linux Kernel</h2><h3 id="Linux-IRQ-number-Hardware-IRQ-number"><a href="#Linux-IRQ-number-Hardware-IRQ-number" class="headerlink" title="Linux IRQ number &amp; Hardware IRQ number"></a>Linux IRQ number &amp; Hardware IRQ number</h3><p>Linux allocates an IRQ number for each interrupt in the system, which is called <em>Linux IRQ number</em> by many. It is used to identify the interrupts. Interrupt numbers shown in <code>/proc/interrupts</code> are Linux IRQ numbers. <em>Hardware IRQ numbers</em>, is another concept, the number “21” in the example above is a hardware IRQ number, it is the “hardware” interrupt number the CPU gets when it asks the interrupt controller for the current interrupt.</p>
<p>You might be wondering why Linux IRQ numbers are necessary, why not just use hardware IRQ numbers for everything?</p>
<p>The answer is yes it would be nice if hardware IRQ numbers are used everywhere, however, computers these days may be connected with more than one interrupt controller, and hardware IRQ numbers would not be enough to identify individual interrupts, as two controllers may have the same hardware IRQ number for two different devices. As a result, the concept of <code>IRQ Domains</code> is introduced to translate between hardware IRQ number and Linux IRQ numbers.</p>
<h3 id="IRQ-Domain"><a href="#IRQ-Domain" class="headerlink" title="IRQ Domain"></a>IRQ Domain</h3><p>Domain as defined in mathematics:</p>
<blockquote>
<p>Domain, the set of inputs accepted by the function. —wikipedia</p>
</blockquote>
<p>In our case, it stands for the different ways for translating hardware IRQ numbers → Linux IRQ numbers. Each interrupt controller has its own IRQ domain, as each interrupt controller has its own way of translating its hardware IRQ numbers to Linux IRQ numbers. Hardware IRQ numbers for an interrupt controller should be translated to Linux IRQ numbers by the interrupt controller’s IRQ domain.</p>
<p>Linux supports two methods for actually translating the IRQ numbers:</p>
<ol>
<li><p>radix tree: taking the hardware IRQ number to lookup a radix tree to retrieve the Linux IRQ number. (I am not familiar with radix trees :P)</p>
</li>
<li><p>array lookup: index an array with the hardware IRQ number to retrieve the Linux IRQ number</p>
</li>
</ol>
<p>I will use the term “revmap” to refer to the data structure (radix tree or array) that does the translation.</p>
<p>The driver for the interrupt controller can choose one of the options as it sees fit, radix tree is more suitable for sparse hardware IRQ numbers though.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span>              <span class="comment">// the irq_domains in the system is linked</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>;</span>   <span class="comment">// callback functions for the interrupt controller</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> revmap_size;           <span class="comment">// size of the revmap array, 0 stands for using radix tree</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">revmap_tree</span>;</span> <span class="comment">// radix tree</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> __<span class="title">rcu</span> *<span class="title">revmap</span>[];</span>    <span class="comment">// array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IRQ-Desc-IRQ-Data-IRQ-Action-Interrupt-Handlers"><a href="#IRQ-Desc-IRQ-Data-IRQ-Action-Interrupt-Handlers" class="headerlink" title="IRQ Desc &amp; IRQ Data &amp; IRQ Action &amp; Interrupt Handlers"></a>IRQ Desc &amp; IRQ Data &amp; IRQ Action &amp; Interrupt Handlers</h3><p>You can see that <code>revmap[]</code> in <code>irq_domain</code> does not store Linux IRQ numbers directly, but pointers to <code>irq_data</code> instead. Each interrupt is allocated an <code>irq_desc</code> as it gets initialized to store some metadata, and <code>irq_data</code> is embedded within <code>irq_desc</code> , therefore each interrupt corresponds to one <code>irq_desc</code> and <code>irq_data</code> . The Linux IRQ number (<code>irq</code>), hardware IRQ number <code>hwirq</code> , and the interrupt handling function (<code>handle_irq</code>) for the interrupt can all be found in its corresponding <code>irq_data</code>. <code>irqaction</code> is a linked list within <code>irq_desc</code> which stores a handler (<code>irqaction→handler</code>) in each node in the list.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> &#123;</span></span><br><span class="line">        u32                     mask;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            irq;            <span class="comment">// Linux IRQ number</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>           hwirq;          <span class="comment">// Hardware IRQ number</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>  *<span class="title">common</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>         *<span class="title">chip</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>       *<span class="title">domain</span>;</span>        <span class="comment">// the irq domain it belongs to</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>         *<span class="title">parent_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">void</span>                    *chip_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>  <span class="title">irq_common_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>         <span class="title">irq_data</span>;</span>       <span class="comment">// the embedded irq_data</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __percpu   *kstat_irqs;</span><br><span class="line">        <span class="type">irq_flow_handler_t</span>      handle_irq;     <span class="comment">// interrupt handler</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>        *<span class="title">action</span>;</span>        <span class="comment">/* IRQ action list */</span></span><br><span class="line">        [...]</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">        <span class="type">irq_handler_t</span>           handler;        <span class="comment">// interrupt handler</span></span><br><span class="line">        <span class="type">void</span>                    *dev_id;</span><br><span class="line">        <span class="type">void</span> __percpu           *percpu_dev_id;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>        *<span class="title">next</span>;</span></span><br><span class="line">        <span class="type">irq_handler_t</span>           thread_fn;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>      *<span class="title">thread</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>        *<span class="title">secondary</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            irq;            <span class="comment">// Linux IRQ number</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            flags;</span><br><span class="line">        [...]</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>Here is the visualized connection of the data structures:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│     irq<span class="emphasis">_domain     │</span></span><br><span class="line"><span class="emphasis">│                    │</span></span><br><span class="line"><span class="emphasis">│ revmap             │</span></span><br><span class="line"><span class="emphasis">│                    │</span></span><br><span class="line"><span class="emphasis">└─┬─┬────────────────┘</span></span><br><span class="line"><span class="emphasis">  │ │</span></span><br><span class="line"><span class="emphasis">  │ │           ┌───────────────┐   ┌─────────────┐   ┌─────────────┐</span></span><br><span class="line"><span class="emphasis">  │ └──────────►│   irq_</span>desc    │ ┌►│  irqaction  ├──►│  irqaction  │</span><br><span class="line">  │             │               │ │ └──────┬──────┘   └──────┬──────┘</span><br><span class="line">  │           ┌─┴────────────┐  │ │        │                 │</span><br><span class="line">  │           │   irq<span class="emphasis">_desc   │  │ │        ▼                 ▼</span></span><br><span class="line"><span class="emphasis">  │           │              │  │ │   ┌─────────┐       ┌─────────┐</span></span><br><span class="line"><span class="emphasis">  │           │ ┌──────────┐ │  │ │   │ handler │       │ handler │</span></span><br><span class="line"><span class="emphasis">  └──────────►│ │ irq_</span>data │ │  ├─┘   └─────────┘       └─────────┘</span><br><span class="line"><span class="code">              │ └──────────┘ ├──┘</span></span><br><span class="line"><span class="code">              │              │   ┌─────────────┐   ┌─────────────┐</span></span><br><span class="line"><span class="code">              │              ├──►│  irqaction  ├──►│  irqaction  │</span></span><br><span class="line"><span class="code">              └──────────────┘   └──────┬──────┘   └──────┬──────┘</span></span><br><span class="line"><span class="code">                                        │                 │</span></span><br><span class="line"><span class="code">                                        ▼                 ▼</span></span><br><span class="line"><span class="code">                                   ┌─────────┐       ┌─────────┐</span></span><br><span class="line"><span class="code">                                   │ handler │       │ handler │</span></span><br><span class="line"><span class="code">                                   └─────────┘       └─────────┘</span></span><br></pre></td></tr></table></figure>

<p>For each interrupt, why do we need <code>irqaction→handler</code> if there is <code>irq_desc→handle_irq</code> already?</p>
<p><code>irq_desc→handle_irq</code> is responsible for interrupt flow control and the interaction between the CPU and the interrupt controller, e.g. masking&#x2F;unmasking interrupts, ACK (acknowledging the interrupt), EOI (signal end-of-interrupt to the interrupt controller), etc. <code>irqaction→handler</code> , on the other hand, <code>irqaction→handler</code> is responsible for device interaction, e.g. accessing the NIC, hard disk, etc. Normally, <code>irqaction→handler</code> is supplied by the device drivers, and <code>irq_desc_handle_irq</code> is set by the interrupt controller, here we name a few:</p>
<ul>
<li><p><code>handle_level_irq</code></p>
</li>
<li><p><code>handle_edge_irq</code></p>
</li>
<li><p><code>handle_fasteoi_irq</code></p>
</li>
<li><p><code>handle_percpu_devid_irq</code></p>
</li>
</ul>
<p>Some call these the IRQ’s <em>high level irq event handler.</em> Moreover, during initialization the interrupt controller has to provide another function for low level interrupt processing such as reading the hardware IRQ number, or lookup <code>irq_desc</code> for the current interrupt. This function should then be pointed to by the global function pointer <code>handle_arch_irq</code> . In our GICv2’s case, that function is <code>gic_handler_irq</code> , driver sets <code>handle_arch_irq</code> to the address of the function <code>gic_handle_irq</code> during initialization.</p>
<h2 id="Linux-Interrupt-Processing-Flow"><a href="#Linux-Interrupt-Processing-Flow" class="headerlink" title="Linux Interrupt Processing Flow"></a>Linux Interrupt Processing Flow</h2><p>Here we go through a simplified interrupt processing flow to help understand all the data structures and interrupt handlers introduced above.</p>
<ol>
<li><p>interrupt arrives, CPU jumps to the corresponding exception vector to save execution context, calls function pointed to by <code>handle_arch_irq</code></p>
</li>
<li><p>the function reads hardware IRQ number from the interrupt controller, and translates hardware IRQ number to Linux IRQ number using the controller’s <code>irq_domain</code> , and retrieves the <code>irq_desc</code> of the interrupt</p>
</li>
<li><p>calls <code>irq_desc→handle_irq</code> (high level irq event handler)</p>
</li>
<li><p>high level irq event handler calls each <code>irq_desc→action→handler</code> in succession</p>
</li>
</ol>
<p>Therefore, the initialization process must set up the three levels of interrupt handlers before interrupts can be handled:</p>
<h3 id="The-global-handle-arch-irq"><a href="#The-global-handle-arch-irq" class="headerlink" title="The global handle_arch_irq"></a>The global <code>handle_arch_irq</code></h3><p>Called by low level exception handling code, set up by the interrupt controller’s driver during controller initialization, this function is called each time an interrupt is being handled.</p>
<h3 id="irq-desc→handle-irq"><a href="#irq-desc→handle-irq" class="headerlink" title="irq_desc→handle_irq"></a><code>irq_desc→handle_irq</code></h3><p>Responsible for interrupt flow control, ACK, EOI, etc. one for each interrupt, also known as the high level event handler of the interrupt.</p>
<h3 id="irqaction→handler"><a href="#irqaction→handler" class="headerlink" title="irqaction→handler"></a><code>irqaction→handler</code></h3><p><code>irq_desc→handle_irq</code> calls each <code>handler</code> in the linked list, there can be many <code>irqaction→handler</code> for each interrupt.</p>
<h2 id="Example-GICv2’s-IPI-Processing"><a href="#Example-GICv2’s-IPI-Processing" class="headerlink" title="Example: GICv2’s IPI Processing"></a>Example: GICv2’s IPI Processing</h2><p>Let’s now take a look at how GICv2 and its IPI (inter processor interrupt) are initialized. The following subsections each describes a step of the process, note that some functions appear in more than one subsection since they do a lot of things.</p>
<blockquote>
<p>It might be helpful to draw your own call graph for the functions mentioned below, there are a lot of them.</p>
</blockquote>
<h3 id="1-Setting-the-global-irq-handler-handle-arch-irq"><a href="#1-Setting-the-global-irq-handler-handle-arch-irq" class="headerlink" title="1. Setting the global irq handler handle_arch_irq"></a>1. Setting the global irq handler <code>handle_arch_irq</code></h3><p><code>start_kernel</code> → <code>init_IRQ</code> → <code>irqchip_init</code> → <code>of_irq_init</code></p>
<p><code>of_irq_init</code> calls GICv2’s initialization callback <code>gic_of_init</code> → <code>__gic_init_bases</code> → <code>set_irq_handler</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init __gic_init_bases(<span class="keyword">struct</span> gic_chip_data *gic,</span><br><span class="line">                                   <span class="keyword">struct</span> fwnode_handle *handle)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gic == &amp;gic_data[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Initialize the CPU interface map to all CPUs.</span></span><br><span class="line"><span class="comment">                 * It will be refined as each CPU probes its ID.</span></span><br><span class="line"><span class="comment">                 * This is only necessary for the primary GIC.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_GIC_CPU_IF; i++)</span><br><span class="line">                        gic_cpu_map[i] = <span class="number">0xff</span>;</span><br><span class="line">                <span class="comment">// sets the global handle_arch_irq</span></span><br><span class="line">                set_handle_irq(gic_handle_irq);</span><br><span class="line">                <span class="keyword">if</span> (static_branch_likely(&amp;supports_deactivate_key))</span><br><span class="line">                        pr_info(<span class="string">&quot;GIC: Using split EOI/Deactivate mode\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ret = gic_init_bases(gic, handle);</span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">set_handle_irq</span><span class="params">(<span class="type">void</span> (*handle_irq)(<span class="keyword">struct</span> pt_regs *))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_arch_irq != default_handle_irq)</span><br><span class="line">                <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        <span class="comment">// sets handle_arch_irq to the address of gic_handle_irq</span></span><br><span class="line">        handle_arch_irq = handle_irq;</span><br><span class="line">        pr_info(<span class="string">&quot;Root IRQ handler: %ps\n&quot;</span>, handle_irq);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Allocate-the-irq-domain-and-its-revmap-for-the-interrupt-controller"><a href="#2-Allocate-the-irq-domain-and-its-revmap-for-the-interrupt-controller" class="headerlink" title="2. Allocate the irq_domain and its revmap for the interrupt controller"></a>2. Allocate the <code>irq_domain</code> and its revmap for the interrupt controller</h3><p>similarly in <code>__gic_init_bases</code> , <code>__gic_init_bases</code> → <code>gic_init_bases</code> → <code>irq_domain_create_linear</code> → <code>__irq_domain_add</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_init_bases</span><span class="params">(<span class="keyword">struct</span> gic_chip_data *gic,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> fwnode_handle *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> gic_irqs, ret;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handle) &#123;           <span class="comment">/* DT/ACPI */</span></span><br><span class="line">                <span class="comment">// allocate irq_domain and revmap for this GIC</span></span><br><span class="line">                gic-&gt;domain = irq_domain_create_linear(handle, gic_irqs,</span><br><span class="line">                                                       &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">                                                       gic);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">/* Legacy support */</span></span><br><span class="line">                [...]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> irq_domain *<span class="title function_">irq_domain_create_linear</span><span class="params">(<span class="keyword">struct</span> fwnode_handle *fwnode,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                                         <span class="type">const</span> <span class="keyword">struct</span> irq_domain_ops *ops,</span></span><br><span class="line"><span class="params">                                         <span class="type">void</span> *host_data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> __irq_domain_add(fwnode, size, size, <span class="number">0</span>, ops, host_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *__<span class="title">irq_domain_add</span>(<span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">irq_hw_number_t</span> <span class="title">hwirq_max</span>, <span class="title">int</span> <span class="title">direct_max</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">void</span> *<span class="title">host_data</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqchip_fwid</span> *<span class="title">fwid</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="type">atomic_t</span> unknown_domains;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// allocate irq_domain and revmap for this GIC</span></span><br><span class="line">        <span class="comment">// size == 0 stands for using radix tree， size != 0 stands for using array</span></span><br><span class="line">        <span class="comment">// GICv2 uses array to translate</span></span><br><span class="line">        domain = kzalloc_node(struct_size(domain, revmap, size),</span><br><span class="line">                              GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));</span><br><span class="line">        <span class="keyword">if</span> (!domain)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fill structure */</span></span><br><span class="line">        INIT_RADIX_TREE(&amp;domain-&gt;revmap_tree, GFP_KERNEL);</span><br><span class="line">        mutex_init(&amp;domain-&gt;revmap_mutex);</span><br><span class="line">        domain-&gt;ops = ops;</span><br><span class="line">        domain-&gt;host_data = host_data;</span><br><span class="line">        domain-&gt;hwirq_max = hwirq_max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (direct_max) &#123;</span><br><span class="line">                domain-&gt;flags |= IRQ_DOMAIN_FLAG_NO_MAP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// size == 0 stands for using radix tree， size != 0 stands for using array</span></span><br><span class="line">        domain-&gt;revmap_size = size;</span><br><span class="line">        [...]</span><br><span class="line">        mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">        debugfs_add_domain_dir(domain);</span><br><span class="line">        <span class="comment">// insert this irq_domain to the global irq_domain_list</span></span><br><span class="line">        list_add(&amp;domain-&gt;link, &amp;irq_domain_list);</span><br><span class="line">        mutex_unlock(&amp;irq_domain_mutex);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Allocate-Linux-IRQ-numbers-and-irq-descs-by-checking-IPI’s-hardware-IRQ-number"><a href="#3-Allocate-Linux-IRQ-numbers-and-irq-descs-by-checking-IPI’s-hardware-IRQ-number" class="headerlink" title="3. Allocate Linux IRQ numbers and irq_descs by checking IPI’s hardware IRQ number"></a>3. Allocate Linux IRQ numbers and <code>irq_desc</code>s by checking IPI’s hardware IRQ number</h3><p><code>__gic_init_bases</code> → <code>gic_smp_init</code> → <code>__irq_domain_alloc_irqs</code> → <code>irq_domain_alloc_descs</code> → <code>__irq_alloc_descs</code> → <code>alloc_descs</code> → <code>alloc_desc</code> &amp; <code>irq_insert_desc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __init <span class="type">void</span> <span class="title function_">gic_smp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> <span class="title">sgi_fwspec</span> =</span> &#123;</span><br><span class="line">                .fwnode         = gic_data[<span class="number">0</span>].domain-&gt;fwnode,</span><br><span class="line">                .param_count    = <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> base_sgi;</span><br><span class="line"></span><br><span class="line">        cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,</span><br><span class="line">                                  <span class="string">&quot;irqchip/arm/gic:starting&quot;</span>,</span><br><span class="line">                                  gic_starting_cpu, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// gic_data[0].domain stores the address of the irq_domain previously</span></span><br><span class="line">        <span class="comment">// allocated</span></span><br><span class="line">        <span class="comment">// -1 stands for not specifying a Linux IRQ number to use</span></span><br><span class="line">        <span class="comment">// 8 is the number of Linux IRQ numbers and irq_descs it wishes to allocate</span></span><br><span class="line">        <span class="comment">// the reason for 8 is probably because GICv2 supports at most 8 CPUs,</span></span><br><span class="line">        <span class="comment">// so it allocates 8 IPI interrupts here</span></span><br><span class="line">        base_sgi = __irq_domain_alloc_irqs(gic_data[<span class="number">0</span>].domain, <span class="number">-1</span>, <span class="number">8</span>,</span><br><span class="line">                                           NUMA_NO_NODE, &amp;sgi_fwspec,</span><br><span class="line">                                           <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (WARN_ON(base_sgi &lt;= <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        set_smp_ipi_range(base_sgi, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __irq_domain_alloc_irqs(<span class="keyword">struct</span> irq_domain *domain, <span class="type">int</span> irq_base,</span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">int</span> node, <span class="type">void</span> *arg,</span><br><span class="line">                            <span class="type">bool</span> <span class="built_in">realloc</span>, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, ret, virq;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">realloc</span> &amp;&amp; irq_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                virq = irq_base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// calling lower-level function</span></span><br><span class="line">                virq = irq_domain_alloc_descs(irq_base, nr_irqs, <span class="number">0</span>, node,</span><br><span class="line">                                              affinity);</span><br><span class="line">                <span class="keyword">if</span> (virq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_debug(<span class="string">&quot;cannot allocate IRQ(base %d, count %d)\n&quot;</span>,</span><br><span class="line">                                 irq_base, nr_irqs);</span><br><span class="line">                        <span class="keyword">return</span> virq;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_domain_alloc_descs</span><span class="params">(<span class="type">int</span> virq, <span class="type">unsigned</span> <span class="type">int</span> cnt, <span class="type">irq_hw_number_t</span> hwirq,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> node, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span></span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line">                <span class="comment">// calling lower-level function</span></span><br><span class="line">                virq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,</span><br><span class="line">                                         affinity);</span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __ref</span><br><span class="line">__irq_alloc_descs(<span class="type">int</span> irq, <span class="type">unsigned</span> <span class="type">int</span> from, <span class="type">unsigned</span> <span class="type">int</span> cnt, <span class="type">int</span> node,</span><br><span class="line">                  <span class="keyword">struct</span> module *owner, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> start, ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cnt)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (irq &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (from &gt; irq)</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                from = irq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * For interrupts which are freely allocated the</span></span><br><span class="line"><span class="comment">                 * architecture can force a lower bound to the @from</span></span><br><span class="line"><span class="comment">                 * argument. x86 uses this to exclude the GSI space.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                from = arch_dynirq_lower_bound(from);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;sparse_irq_lock);</span><br><span class="line">        <span class="comment">// allocated_irqs is a global bitmap recording the allocation status</span></span><br><span class="line">        <span class="comment">// for all Linux IRQ numbers,</span></span><br><span class="line">        <span class="comment">// e.g. allocated_irqs[10] == 1 stands for Linux IRQ number 10 is in use</span></span><br><span class="line">        <span class="comment">// here we look for a continuous range of unused Linux IRQ numbers</span></span><br><span class="line">        start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,</span><br><span class="line">                                           from, cnt, <span class="number">0</span>);</span><br><span class="line">        ret = -EEXIST;</span><br><span class="line">        <span class="keyword">if</span> (irq &gt;=<span class="number">0</span> &amp;&amp; start != irq)</span><br><span class="line">                <span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start + cnt &gt; nr_irqs) &#123;</span><br><span class="line">                ret = irq_expand_nr_irqs(start + cnt);</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br><span class="line">                        <span class="keyword">goto</span> unlock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// calling lower-level function</span></span><br><span class="line">        ret = alloc_descs(start, cnt, node, affinity, owner);</span><br><span class="line">unlock:</span><br><span class="line">        mutex_unlock(&amp;sparse_irq_lock);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_descs</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> cnt, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> module *owner)</span></span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// each loop allocates a single irq_desc</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">mask</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                [...]</span><br><span class="line">                <span class="comment">// actually calls kzmalloc to allocate irq_desc and init some fields</span></span><br><span class="line">                <span class="comment">// we don&#x27;t dive into this function for simplicity</span></span><br><span class="line">                desc = alloc_desc(start + i, node, flags, mask, owner);</span><br><span class="line">                <span class="keyword">if</span> (!desc)</span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                <span class="comment">// insert the allocated irq_desc into the global radix tree</span></span><br><span class="line">                <span class="comment">// irq_desc_tree using Linux IRQ number as its key</span></span><br><span class="line">                <span class="comment">// (do not confuse this with revmap)</span></span><br><span class="line">                irq_insert_desc(start + i, desc);</span><br><span class="line">                [...]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set the index used in allocated_irqs to 1</span></span><br><span class="line">        bitmap_set(allocated_irqs, start, cnt);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">irq_insert_desc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">        radix_tree_insert(&amp;irq_desc_tree, irq, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Set-up-IPI’s-irq-desc→handle-irq-in-GICv2’s-callback"><a href="#4-Set-up-IPI’s-irq-desc→handle-irq-in-GICv2’s-callback" class="headerlink" title="4. Set up IPI’s irq_desc→handle_irq in GICv2’s callback"></a>4. Set up IPI’s <code>irq_desc→handle_irq</code> in GICv2’s callback</h3><p>The previous step only allocated <code>irq_desc</code> , next is to set <code>irq_desc→handle_irq</code>.</p>
<p><code>__irq_domain_alloc_descs</code> → <code>irq_domain_alloc_irqs_hierarchy</code> → <code>gic_irq_domain_alloc</code> → <code>gic_irq_domain_map</code> → <code>irq_domain_set_info</code> → <code>__irq_set_handler</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __irq_domain_alloc_irqs(<span class="keyword">struct</span> irq_domain *domain, <span class="type">int</span> irq_base,</span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">int</span> node, <span class="type">void</span> *arg,</span><br><span class="line">                            <span class="type">bool</span> <span class="built_in">realloc</span>, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">realloc</span> &amp;&amp; irq_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                virq = irq_base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// allocate irq_desc &amp; Linux IRQ numbers, as mentioned in 3.</span></span><br><span class="line">                virq = irq_domain_alloc_descs(irq_base, nr_irqs, <span class="number">0</span>, node,</span><br><span class="line">                                              affinity);</span><br><span class="line">                <span class="keyword">if</span> (virq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_debug(<span class="string">&quot;cannot allocate IRQ(base %d, count %d)\n&quot;</span>,</span><br><span class="line">                                 irq_base, nr_irqs);</span><br><span class="line">                        <span class="keyword">return</span> virq;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">        <span class="comment">// continue processing</span></span><br><span class="line">        ret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_domain_alloc_irqs_hierarchy</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">int</span> irq_base,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!domain-&gt;ops-&gt;alloc) &#123;</span><br><span class="line">                pr_debug(<span class="string">&quot;domain-&gt;ops-&gt;alloc() is NULL\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// call irq_domain&#x27;s alloc callback,</span></span><br><span class="line">        <span class="comment">// in this case it&#x27;s gic_irq_domain_alloc</span></span><br><span class="line">        <span class="comment">// you can try to find where in the code did domain-&gt;ops got</span></span><br><span class="line">        <span class="comment">// assigned, hint: it can be found within this post</span></span><br><span class="line">        <span class="keyword">return</span> domain-&gt;ops-&gt;alloc(domain, irq_base, nr_irqs, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, ret;</span><br><span class="line">        <span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> *<span class="title">fwspec</span> =</span> arg;</span><br><span class="line">        <span class="comment">// get hardware IRQ number,</span></span><br><span class="line">        <span class="comment">// in this case GIC&#x27;s IPI IRQ number ranges from 0 to 15,</span></span><br><span class="line">        <span class="comment">// we only use 8 here so it is 0-7</span></span><br><span class="line">        ret = gic_irq_domain_translate(domain, fwspec, &amp;hwirq, &amp;type);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">// each loop sets irq_desc-&gt;handle_irq for one IRQ</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++) &#123;</span><br><span class="line">                ret = gic_irq_domain_map(domain, virq + i, hwirq + i);</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                                <span class="type">irq_hw_number_t</span> hw)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> d-&gt;host_data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">irqd</span> =</span> irq_desc_get_irq_data(irq_to_desc(irq));</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">        chip = (static_branch_likely(&amp;supports_deactivate_key) &amp;&amp;</span><br><span class="line">                gic == &amp;gic_data[<span class="number">0</span>]) ? &amp;gic_chip_mode1 : &amp;gic_chip;</span><br><span class="line">        <span class="comment">// two switch cases here because numbers 0-31 of GICv2&#x27;s hardware</span></span><br><span class="line">        <span class="comment">// IRQ number are banked per PE, therefore they are processed</span></span><br><span class="line">        <span class="comment">// differently from the rest. In our case we are using 0-7 so</span></span><br><span class="line">        <span class="comment">// the first case is run</span></span><br><span class="line">        <span class="keyword">switch</span> (hw) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">31</span>:</span><br><span class="line">                irq_set_percpu_devid(irq);</span><br><span class="line">                <span class="comment">// set the high level IRQ event handler to the function</span></span><br><span class="line">                <span class="comment">// handle_percpu_devid_irq</span></span><br><span class="line">                irq_domain_set_info(d, irq, hw, chip, d-&gt;host_data,</span><br><span class="line">                                    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                irq_domain_set_info(d, irq, hw, chip, d-&gt;host_data,</span><br><span class="line">                                    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                irq_set_probe(irq);</span><br><span class="line">                irqd_set_single_target(irqd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Prevents SW retriggers which mess up the ACK/EOI ordering */</span></span><br><span class="line">        irqd_set_handle_enforce_irqctx(irqd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_domain_set_info</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">                         <span class="type">irq_hw_number_t</span> hwirq, <span class="type">const</span> <span class="keyword">struct</span> irq_chip *chip,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span> *chip_data, <span class="type">irq_flow_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span> *handler_data, <span class="type">const</span> <span class="type">char</span> *handler_name)</span></span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// this is the function that actually assigns irq_desc-&gt;handle_irq</span></span><br><span class="line">        <span class="comment">// (desc-&gt;handle_irq = handler)</span></span><br><span class="line">        <span class="comment">// however it is not expanded since it does a lot of other</span></span><br><span class="line">        <span class="comment">// complicated work</span></span><br><span class="line">        __irq_set_handler(virq, handler, <span class="number">0</span>, handler_name);</span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Create-revmap-for-translating-hardware-IRQ-number-→-Linux-IRQ-number"><a href="#5-Create-revmap-for-translating-hardware-IRQ-number-→-Linux-IRQ-number" class="headerlink" title="5. Create revmap for translating hardware IRQ number → Linux IRQ number"></a>5. Create revmap for translating hardware IRQ number → Linux IRQ number</h3><p><code>__irq_domain_alloc_descs</code> → <code>irq_domain_insert_irq</code> → <code>irq_domain_set_mapping</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __irq_domain_alloc_irqs(<span class="keyword">struct</span> irq_domain *domain, <span class="type">int</span> irq_base,</span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">int</span> node, <span class="type">void</span> *arg,</span><br><span class="line">                            <span class="type">bool</span> <span class="built_in">realloc</span>, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">realloc</span> &amp;&amp; irq_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                virq = irq_base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// allocate irq_desc &amp; Linux IRQ numbers, as mentioned in 3.</span></span><br><span class="line">                virq = irq_domain_alloc_descs(irq_base, nr_irqs, <span class="number">0</span>, node,</span><br><span class="line">                                              affinity);</span><br><span class="line">                <span class="keyword">if</span> (virq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_debug(<span class="string">&quot;cannot allocate IRQ(base %d, count %d)\n&quot;</span>,</span><br><span class="line">                                 irq_base, nr_irqs);</span><br><span class="line">                        <span class="keyword">return</span> virq;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">        <span class="comment">// set irq_desc-&gt;handle_irq, as mentioned in 4.</span></span><br><span class="line">        ret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// each loop set ups revmap for one IRQ</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++)</span><br><span class="line">                irq_domain_insert_irq(virq + i);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">irq_domain_insert_irq</span><span class="params">(<span class="type">int</span> virq)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">data</span>;</span></span><br><span class="line">        <span class="comment">// in my understanding this loop is related to chained interrupt</span></span><br><span class="line">        <span class="comment">// controllers, hence it is run only once in our case</span></span><br><span class="line">        <span class="keyword">for</span> (data = irq_get_irq_data(virq); data; data = data-&gt;parent_data) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span> =</span> data-&gt;domain;</span><br><span class="line"></span><br><span class="line">                domain-&gt;mapcount++;</span><br><span class="line">                <span class="comment">// keep on processing</span></span><br><span class="line">                irq_domain_set_mapping(domain, data-&gt;hwirq, data);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* If not already assigned, give the domain the chip&#x27;s name */</span></span><br><span class="line">                <span class="keyword">if</span> (!domain-&gt;name &amp;&amp; data-&gt;chip)</span><br><span class="line">                        domain-&gt;name = data-&gt;chip-&gt;name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        irq_clear_status_flags(virq, IRQ_NOREQUEST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">irq_domain_set_mapping</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">                                   <span class="type">irq_hw_number_t</span> hwirq,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> irq_data *irq_data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (irq_domain_is_nomap(domain))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;domain-&gt;revmap_mutex);</span><br><span class="line">        <span class="comment">// use array or radix tree?</span></span><br><span class="line">        <span class="comment">// array (in GICv2&#x27;s case)</span></span><br><span class="line">        <span class="keyword">if</span> (hwirq &lt; domain-&gt;revmap_size)</span><br><span class="line">                <span class="comment">// simply assign the irq_data of IRQ into revmap array</span></span><br><span class="line">                <span class="comment">// with hardware IRQ number as the index</span></span><br><span class="line">                rcu_assign_pointer(domain-&gt;revmap[hwirq], irq_data);</span><br><span class="line">        <span class="comment">// radix tree</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                radix_tree_insert(&amp;domain-&gt;revmap_tree, hwirq, irq_data);</span><br><span class="line">        mutex_unlock(&amp;domain-&gt;revmap_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-allocate-and-insert-irqaction-in-linked-list-irq-desc→action-in-request-percpu-irq"><a href="#6-allocate-and-insert-irqaction-in-linked-list-irq-desc→action-in-request-percpu-irq" class="headerlink" title="6. allocate and insert irqaction in linked list irq_desc→action , in request_percpu_irq"></a>6. allocate and insert <code>irqaction</code> in linked list <code>irq_desc→action</code> , in <code>request_percpu_irq</code></h3><p>Next, <code>gic_smp_init</code> → <code>set_smp_ipi_range</code> calls<code>request_percpu_irq</code> to allocate <code>irqaction</code> and insert it in <code>irq_desc→action</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">set_smp_ipi_range</span><span class="params">(<span class="type">int</span> ipi_base, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        WARN_ON(n &lt; NR_IPI);</span><br><span class="line">        nr_ipi = min(n, NR_IPI);</span><br><span class="line">        <span class="comment">// each loop sets up an irqaction for an IRQ</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_ipi; i++) &#123;</span><br><span class="line">                <span class="type">int</span> err;</span><br><span class="line">                <span class="comment">// set ipi_handler as irqaction-&gt;handler and insert it</span></span><br><span class="line">                <span class="comment">// in irq_desc-&gt;action</span></span><br><span class="line">                err = request_percpu_irq(ipi_base + i, ipi_handler,</span><br><span class="line">                                         <span class="string">&quot;IPI&quot;</span>, &amp;cpu_number);</span><br><span class="line">                WARN_ON(err);</span><br><span class="line"></span><br><span class="line">                ipi_desc[i] = irq_to_desc(ipi_base + i);</span><br><span class="line">                irq_set_status_flags(ipi_base + i, IRQ_HIDDEN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_percpu_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> __percpu *percpu_dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> __request_percpu_irq(irq, handler, <span class="number">0</span>,</span><br><span class="line">                                    devname, percpu_dev_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __request_percpu_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span><br><span class="line">                         <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *devname,</span><br><span class="line">                         <span class="type">void</span> __percpu *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        desc = irq_to_desc(irq);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// allocate an irqaction</span></span><br><span class="line">        action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!action)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="comment">// set its action-&gt;handler (ipi_handler)</span></span><br><span class="line">        action-&gt;handler = handler;</span><br><span class="line">        action-&gt;flags = flags | IRQF_PERCPU | IRQF_NO_SUSPEND;</span><br><span class="line">        action-&gt;name = devname;</span><br><span class="line">        action-&gt;percpu_dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// this is a big function, responsible for inserting the newly</span></span><br><span class="line">        <span class="comment">// allocated irqaction into irq_desc-&gt;action</span></span><br><span class="line">        retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux-Interrupt-Handling-Concepts-not-Mentioned"><a href="#Linux-Interrupt-Handling-Concepts-not-Mentioned" class="headerlink" title="Linux Interrupt Handling Concepts not Mentioned"></a>Linux Interrupt Handling Concepts not Mentioned</h2><ul>
<li><p>threaded IRQs</p>
</li>
<li><p>chained interrupt controllers</p>
</li>
<li><p>nested interrupt controllers</p>
</li>
<li><p>shared IRQs</p>
</li>
<li><p>spurious interrupts</p>
</li>
<li><p>softirqs</p>
</li>
<li><p>tasklets</p>
</li>
<li><p>workqueues</p>
</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/sort/irq_subsystem">中断子系统 - 蜗窝科技 (</a><a href="wowotech.net">wowotech.net</a><a target="_blank" rel="noopener" href="http://www.wowotech.net/sort/irq_subsystem">)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://youtu.be/LOCsN3V1ECE?si=piviVroOdJ_UVgnl">Understanding Linux Interrupt Subsystem - Priya Dixit, Samsung Semiconductor India Research</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://youtu.be/YE8cRHVIM4E?si=ENdH1X5EEDCMxCwI">How Dealing with Modern Interrupt Architectures can Affect Your Sanity</a></p>
</li>
</ul>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Quick-Intro-to-OS-Interrupts"><span class="top-box-text">Quick Intro to OS Interrupts</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Interrupt-Management-and-Data-Structures-used-in-the-Linux-Kernel"><span class="top-box-text">Interrupt Management and Data Structures used in the Linux Kernel</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Linux-IRQ-number-Hardware-IRQ-number"><span class="top-box-text">Linux IRQ number &amp; Hardware IRQ number</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IRQ-Domain"><span class="top-box-text">IRQ Domain</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IRQ-Desc-IRQ-Data-IRQ-Action-Interrupt-Handlers"><span class="top-box-text">IRQ Desc &amp; IRQ Data &amp; IRQ Action &amp; Interrupt Handlers</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux-Interrupt-Processing-Flow"><span class="top-box-text">Linux Interrupt Processing Flow</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#The-global-handle-arch-irq"><span class="top-box-text">The global handle_arch_irq</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#irq-desc%E2%86%92handle-irq"><span class="top-box-text">irq_desc→handle_irq</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#irqaction%E2%86%92handler"><span class="top-box-text">irqaction→handler</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Example-GICv2%E2%80%99s-IPI-Processing"><span class="top-box-text">Example: GICv2’s IPI Processing</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-Setting-the-global-irq-handler-handle-arch-irq"><span class="top-box-text">1. Setting the global irq handler handle_arch_irq</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-Allocate-the-irq-domain-and-its-revmap-for-the-interrupt-controller"><span class="top-box-text">2. Allocate the irq_domain and its revmap for the interrupt controller</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-Allocate-Linux-IRQ-numbers-and-irq-descs-by-checking-IPI%E2%80%99s-hardware-IRQ-number"><span class="top-box-text">3. Allocate Linux IRQ numbers and irq_descs by checking IPI’s hardware IRQ number</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-Set-up-IPI%E2%80%99s-irq-desc%E2%86%92handle-irq-in-GICv2%E2%80%99s-callback"><span class="top-box-text">4. Set up IPI’s irq_desc→handle_irq in GICv2’s callback</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#5-Create-revmap-for-translating-hardware-IRQ-number-%E2%86%92-Linux-IRQ-number"><span class="top-box-text">5. Create revmap for translating hardware IRQ number → Linux IRQ number</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#6-allocate-and-insert-irqaction-in-linked-list-irq-desc%E2%86%92action-in-request-percpu-irq"><span class="top-box-text">6. allocate and insert irqaction in linked list irq_desc→action , in request_percpu_irq</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux-Interrupt-Handling-Concepts-not-Mentioned"><span class="top-box-text">Linux Interrupt Handling Concepts not Mentioned</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#References"><span class="top-box-text">References</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/interrupt1/">
          <h3 class="post-title">
            Next: Linux中斷子系統簡介(1): 中斷處理流程的建立
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

