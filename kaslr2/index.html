<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>Linux ARM64 KASLR 實作分析(2): 線性位址隨機化</title>
<meta name="google-site-verification" content="CmjL_aZ8fDb2ZxqOct5raymSCyinEt7dd7JeIro6eig" />
<meta name="keywords" content="Linux ARM64 KASLR 實作分析(2): 線性位址隨機化, blog keywords">
<meta name="description" content="
Linux版本：v6.0
處理器架構：ARMv8

這篇接續Linux ARM64 KASLR 實作分析(1): 內核映像位址隨機化
線性位址隨機化實作機制memstart_offset_seed 的來由上篇說到在__primary_sw">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>





  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://rhythm16.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://rhythm16.github.io">
        <h1 class="site-title">rhythm16.github.io</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        Home
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        Categories
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        Archives
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Linux ARM64 KASLR 實作分析(2): 線性位址隨機化</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-04-15</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/ARMv8/">
              ARMv8
                
                  ，
                
              </a>
            
              <a href="/tags/KASLR/">
              KASLR
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>Linux版本：v6.0</p>
<p>處理器架構：ARMv8</p>
</blockquote>
<p>這篇接續<a href="../kaslr/">Linux ARM64 KASLR 實作分析(1): 內核映像位址隨機化</a></p>
<h2 id="線性位址隨機化實作機制"><a href="#線性位址隨機化實作機制" class="headerlink" title="線性位址隨機化實作機制"></a>線性位址隨機化實作機制</h2><h3 id="memstart-offset-seed-的來由"><a href="#memstart-offset-seed-的來由" class="headerlink" title="memstart_offset_seed 的來由"></a><code>memstart_offset_seed</code> 的來由</h3><p>上篇說到在<code>__primary_switch</code> 中，程式呼叫了<code>__pi_kaslr_early_init</code> 來獲得KASLR使用的隨機偏移，並且把低20位存在暫存器x24中。接著在 <code>__primary_switched</code> 中把x24的值存到<code>memstart_offset_seed</code>: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line">        adrp    x5, memstart_offset_seed        <span class="comment">// Save KASLR linear map seed    </span></span><br><span class="line">        strh    w24, [x5, :lo12:memstart_offset_seed]</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></table></figure>

<p><code>memstart_offset_seed</code> 在<code>arch/arm64/kernel/kaslr.c</code> 中被定義:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u16 __initdata memstart_offset_seed;</span><br></pre></td></tr></table></figure>

<p>可以看到它是個u16，所以上面使用<code>strh</code>，使得其剩下16位的隨機值。</p>
<h3 id="arm64-memblock-init"><a href="#arm64-memblock-init" class="headerlink" title="arm64_memblock_init"></a><code>arm64_memblock_init</code></h3><p>接下來的初始化流程會執行到<code>arm64_memblock_init</code> 函式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line"> --&gt; setup_arch</span><br><span class="line">      --&gt; arm64_memblock_init</span><br><span class="line">      --&gt; paging_init </span><br></pre></td></tr></table></figure>

<p>擷取與KASLR有關的部份：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">arm64_memblock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Select a suitable value for the base of physical memory.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 設定memstart_addr為DRAM開始的位址(然後做一個對齊)</span></span><br><span class="line">        memstart_addr = round_down(memblock_start_of_DRAM(),</span><br><span class="line">                                   ARM64_MEMSTART_ALIGN);</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果KASLR開啟</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) &#123;</span><br><span class="line">                <span class="comment">// 取得16位的隨機值</span></span><br><span class="line">                <span class="keyword">extern</span> u16 memstart_offset_seed;</span><br><span class="line">                <span class="comment">// 讀取CPU能夠支援的物理位址區間大小</span></span><br><span class="line">                u64 mmfr0 = read_cpuid(ID_AA64MMFR0_EL1);</span><br><span class="line">                <span class="type">int</span> parange = cpuid_feature_extract_unsigned_field(</span><br><span class="line">                                        mmfr0, ID_AA64MMFR0_PARANGE_SHIFT);</span><br><span class="line">                <span class="comment">// linear_region_size為kernel計算出之線性映射區間大小</span></span><br><span class="line">                <span class="comment">// linear_region_size減去物理位址區間大小，得到range</span></span><br><span class="line">                <span class="comment">// 所以這個range代表物理位址在線性映射區間中有多少移動空間</span></span><br><span class="line">                s64 range = linear_region_size -</span><br><span class="line">                            BIT(id_aa64mmfr0_parange_to_phys_shift(parange));</span><br><span class="line">    </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * If the size of the linear region exceeds, by a sufficient</span></span><br><span class="line"><span class="comment">                 * margin, the size of the region that the physical memory can</span></span><br><span class="line"><span class="comment">                 * span, randomize the linear region as well.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 如果隨機值非0，而且移動空間大於ARM64_MEMSTART_ALIGN (隨機化空間夠大)</span></span><br><span class="line">                <span class="comment">// 則用改變memstart_addr的方式來隨機化線性空間</span></span><br><span class="line">                <span class="keyword">if</span> (memstart_offset_seed &gt; <span class="number">0</span> &amp;&amp; range &gt;= (s64)ARM64_MEMSTART_ALIGN) &#123;</span><br><span class="line">                        range /= ARM64_MEMSTART_ALIGN;</span><br><span class="line">                <span class="comment">// 下面這行要減的值不是很好理解，可以用數學的方式重新排列想像成</span></span><br><span class="line">                <span class="comment">// (range * ARM64_MEMSTART_ALIGN) * (memstart_offset_seed &gt;&gt; 16)</span></span><br><span class="line">                <span class="comment">// 也就是 (range原本的值，因為前面range被除ARM64_MEMSTART_ALIGN) * </span></span><br><span class="line">                <span class="comment">// (memstart_offset_seed / (1 &lt;&lt; 16) 也就是一個0~1的隨機值)</span></span><br><span class="line">                <span class="comment">// 所以算下來就是一個 (0~原本的range) 的隨機值</span></span><br><span class="line">                        memstart_addr -= ARM64_MEMSTART_ALIGN *</span><br><span class="line">                                         ((range * memstart_offset_seed) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那為何改變<code>memstart_addr</code> 就會改變線性空間位址呢？</p>
<h3 id="線性映射隨機化"><a href="#線性映射隨機化" class="headerlink" title="線性映射隨機化"></a>線性映射隨機化</h3><p>我們來看一下真正要隨機化線性空間的頁表操作。線性空間的頁表是在<code>paging_init</code> → <code>map_mem</code>中建立的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">map_mem</span><span class="params">(<span class="type">pgd_t</span> *pgdp)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* map all the memory banks */</span></span><br><span class="line">        <span class="comment">// 這個迴圈把系統對所有物理記憶體區間都呼叫__map_memblock製作線性映射</span></span><br><span class="line">        for_each_mem_range(i, &amp;start, &amp;end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The linear map must allow allocation tags reading/writing</span></span><br><span class="line"><span class="comment">                 * if MTE is present. Otherwise, it has the same attributes as</span></span><br><span class="line"><span class="comment">                 * PAGE_KERNEL.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// start為起始物理位址</span></span><br><span class="line">                <span class="comment">// end為結束的物理位址</span></span><br><span class="line">                <span class="comment">// pgdp為swapper_pg_dir，kernel之後即將使用的頁表的根</span></span><br><span class="line">                __map_memblock(pgdp, start, end, pgprot_tagged(PAGE_KERNEL),</span><br><span class="line">                               flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map-memblock"><a href="#map-memblock" class="headerlink" title="__map_memblock"></a><code>__map_memblock</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init __map_memblock(<span class="type">pgd_t</span> *pgdp, <span class="type">phys_addr_t</span> start,</span><br><span class="line">                                  <span class="type">phys_addr_t</span> end, <span class="type">pgprot_t</span> prot, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">        __create_pgd_mapping(pgdp, start, __phys_to_virt(start), end - start,</span><br><span class="line">                             prot, early_pgtable_alloc, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__create_pgd_mapping</code> 在 <a href="../page_table/">Linux ARM64 <code>__create_pgd_mapping</code> 分析</a> 有詳細的介紹，這邊重點在於<code>[start - end)</code> 這段物理位址區間在這裡被建立了一個到<code>[__phys_to_virt(start) - __phys_to_virt(end))</code> 的頁表映射，也就是說<code>__phys_to_virt</code> 決定了線性映射的虛擬位址</p>
<h3 id="phys-to-virt"><a href="#phys-to-virt" class="headerlink" title="__phys_to_virt"></a><code>__phys_to_virt</code></h3><p>macro定義在<code>arch/arm64/include/asm/memory.h</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __phys_to_virt(x)       ((unsigned long)((x) - PHYS_OFFSET) | PAGE_OFFSET)</span></span><br></pre></td></tr></table></figure>

<p>而在同個檔案中 <code>PHYS_OFFSET</code> 基本被定義為<code>memstart_addr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> s64                      memstart_addr;</span><br><span class="line"><span class="comment">/* PHYS_OFFSET - the physical address of the start of memory. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYS_OFFSET             (&#123; VM_BUG_ON(memstart_addr &amp; 1); memstart_addr; &#125;)</span></span><br></pre></td></tr></table></figure>

<p>這樣子就接回<code>memstart_addr</code> 了，<code>memstart_addr</code> 在<code>arm64_memblock_init</code> 中被減去一個隨機值，導致<code>PHYS_OFFSET</code> 和<code>__phys_to_virt</code> 被隨機化，所以<code>paging_init</code> → <code>map_mem</code> → <code>___map_memblock</code> → <code>__create_pgd_mapping</code> 製作的線性映射的虛擬位址也就被隨機化了。</p>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%B7%9A%E6%80%A7%E4%BD%8D%E5%9D%80%E9%9A%A8%E6%A9%9F%E5%8C%96%E5%AF%A6%E4%BD%9C%E6%A9%9F%E5%88%B6"><span class="top-box-text">線性位址隨機化實作機制</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#memstart-offset-seed-%E7%9A%84%E4%BE%86%E7%94%B1"><span class="top-box-text">memstart_offset_seed 的來由</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#arm64-memblock-init"><span class="top-box-text">arm64_memblock_init</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B7%9A%E6%80%A7%E6%98%A0%E5%B0%84%E9%9A%A8%E6%A9%9F%E5%8C%96"><span class="top-box-text">線性映射隨機化</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#map-memblock"><span class="top-box-text">__map_memblock</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#phys-to-virt"><span class="top-box-text">__phys_to_virt</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/page_table_en/">
          <h3 class="post-title">
            Next: Linux ARM64 `__create_pgd_mapping` Analysis
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

