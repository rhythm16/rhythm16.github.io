<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>為什麼KVM重新初始化vCPU時要清除所有stage 2地址轉換?</title>
<meta name="google-site-verification" content="CmjL_aZ8fDb2ZxqOct5raymSCyinEt7dd7JeIro6eig" />
<meta name="keywords" content="為什麼KVM重新初始化vCPU時要清除所有stage 2地址轉換?, blog keywords">
<meta name="description" content="
對於這篇我原本是想要寫的順一點的，但寫到後來實在是太雜了也太多背景知識要補充，所以最後比較像是一份雜亂的筆記😅 有興趣的人如果有問題歡迎來信討論

此文中”guest”與”VM”與”guest VM”這三個詞是一樣的意思
Arm Arc">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>





  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://rhythm16.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://rhythm16.github.io">
        <h1 class="site-title">rhythm16.github.io</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        Home
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        Categories
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        Archives
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">為什麼KVM重新初始化vCPU時要清除所有stage 2地址轉換?</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-10-30</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/KVM/">
              KVM
                
                  ，
                
              </a>
            
              <a href="/tags/ARMv8/">
              ARMv8
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>對於這篇我原本是想要寫的順一點的，但寫到後來實在是太雜了也太多背景知識要補充，所以最後比較像是一份雜亂的筆記😅 有興趣的人如果有問題歡迎來信討論</p>
</blockquote>
<p>此文中”guest”與”VM”與”guest VM”這三個詞是一樣的意思</p>
<p>Arm Architecture Reference Manual使用K.a版本</p>
<h2 id="一個在讀code遇到的疑問"><a href="#一個在讀code遇到的疑問" class="headerlink" title="一個在讀code遇到的疑問"></a>一個在讀code遇到的疑問</h2><p>我在看KVM code時看到這一部分:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kvm_arch_vcpu_ioctl_vcpu_init</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu,</span></span><br><span class="line"><span class="params">					 <span class="keyword">struct</span> kvm_vcpu_init *init)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure a rebooted VM will fault in RAM pages and detect if the</span></span><br><span class="line"><span class="comment">	 * guest MMU is turned off and flush the caches as needed.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * S2FWB enforces all memory accesses to RAM being cacheable,</span></span><br><span class="line"><span class="comment">	 * ensuring that the data side is always coherent. We still</span></span><br><span class="line"><span class="comment">	 * need to invalidate the I-cache though, as FWB does *not*</span></span><br><span class="line"><span class="comment">	 * imply CTR_EL0.DIC.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 此vCPU有跑過一次了，代表是重新初始化</span></span><br><span class="line">	<span class="keyword">if</span> (vcpu_has_run_once(vcpu)) &#123;</span><br><span class="line">        <span class="comment">// 如果沒有FEAT_FWB功能</span></span><br><span class="line">		<span class="keyword">if</span> (!cpus_have_final_cap(ARM64_HAS_STAGE2_FWB))</span><br><span class="line">            <span class="comment">// 就把所有stage2 mapping給unmap</span></span><br><span class="line">			stage2_unmap_vm(vcpu-&gt;kvm);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			icache_inval_all_pou();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在都先假設沒有FEAT_FWB，此篇不考慮有FWB的情況</p>
<p>老實說，看不懂為什麼重新初始化就要把stage2給unmap掉。先來看看註解，第一部分就是針對此情況:</p>
<blockquote>
<p>Ensure a rebooted VM will fault in RAM pages</p>
</blockquote>
<p>「在VM(和vCPU)重開機的情況下，確保vCPU重新page fault，再次建立stage 2 mapping」<br>其實只是描述在做的事情，並沒有解釋原因</p>
<blockquote>
<p>and detect if the guest MMU is turned off and flush the caches as needed</p>
</blockquote>
<p>「偵測guest是否將MMU關閉，並把該flush的給flush掉 (i.e. 把髒數據寫回)」</p>
<p>首先，這裡沒有程式在”偵測” guest有沒有把MMU關掉，所以這部分不知所云，後面說適時地把髒數據寫回，聽起來好像有必要，但是什麼時候需要呢? 也沒有解釋</p>
<h2 id="Mailing-List怎麼說"><a href="#Mailing-List怎麼說" class="headerlink" title="Mailing List怎麼說"></a>Mailing List怎麼說</h2><p>遇到程式看不懂的時候就是挖mailing list的時候了，<code>git blame</code> 然後看一下commit通常就可以連到當初的email thread，這幾行程式經過了幾次的修改，討論比較完整的是<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20200415072835.1164-1-yuzenghui@huawei.com/">這串</a>，其中Alexandru Elisei說了為什麼當初Christoffer Dall要加上<code>stage2_unmap_vm</code>:</p>
<blockquote>
<p>I had a chat with Christoffer about stage2_unmap_vm, and as I understood it, the purpose was to make sure that any changes made by userspace were seen by the guest while the MMU is off. When a stage 2 fault happens, we do clean+inval on the dcache, or inval on the icache if it was an exec fault. This means that whatever the host userspace writes while the guest is shut down and is still in the cache, the guest will be able to read&#x2F;execute.</p>
<p>This can be relevant if the guest relocates the kernel and overwrites the original image location, and userspace copies the original kernel image back in before restarting the vm.</p>
</blockquote>
<p>所以說unmap的用意是要讓guest重開機再次運行時能夠看見userspace (在跑guest之前) 所更改的記憶體內容，具體的例子是guest relocate kernel，並把原本kernel的位置給寫了別的東西，接著host userspace把VM暫停，把kernel image寫回原本的地方，接著重新開機。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有了以上的補充之後先來整理一下這個過程發生了什麼事</p>
<ol>
<li><p>guest正常運行，讀寫記憶體</p>
</li>
<li><p>因interrupt, exception等因素切換回userspace</p>
</li>
<li><p>userspace暫停guest，並且打算將VM重新開機，所以重置並改寫了所有的guest memory，vCPU暫存器等等</p>
</li>
<li><p>userspace呼叫KVM API來重新init該vCPU</p>
</li>
<li><p>guest重新開始執行，重開機開始執行時，guest的MMU是關掉的</p>
</li>
</ol>
<p>這個過程中，乍看之下如果KVM什麼都不做，可能會有2個問題:</p>
<ol>
<li><p>guest在被暫停之前(第1步)因為使用與host不同的address space，所以coherency被打破，接著出現以下狀況</p>
<ol>
<li><p>第一步時guest存取X虛擬位址，其實體位址為P，所以X(P)存在於cache中</p>
</li>
<li><p>第三步時host改寫guest記憶體，存取了Y虛擬位址，其實體位址也為P，所以Y(P)和X(P)存在於cache中</p>
</li>
<li><p>硬體決定把Y(P) clean到主記憶體，並且invalidate</p>
</li>
<li><p>硬體決定把X(P) clean到主記憶體，並且invalidate，結果最後主記憶體得到舊的數據，cache中的新數據也沒了</p>
</li>
</ol>
</li>
<li><p>guest在第5步時存取到舊的值(guest被暫停前的值)，而不是第3步host改寫的值</p>
<ol>
<li><p>第一步時guest存取記憶體，內容存在cache中，也被硬體flush到主記憶體</p>
</li>
<li><p>第三步時host改寫了guest的記憶體，但是內容只被存在cache中，沒有被硬體flush到主記憶體</p>
</li>
<li><p>第五步guest重新執行時，因為沒有打開MMU，導致CPU直接從主記憶體存取資料，就拿到了舊的資料</p>
</li>
</ol>
</li>
</ol>
<h3 id="問題1"><a href="#問題1" class="headerlink" title="問題1"></a>問題1</h3><p>先來看看問題1有沒有可能出現，此狀況要分成2個case來討論:</p>
<p>第一，如果guest的memory access attributes與host相同，那比較簡單</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">D8.17.1 Data and unified caches</span><br><span class="line"></span><br><span class="line">R_JHVQL</span><br><span class="line">For data and unified caches, if all data accesses to an address do not use mismatched memory attributes, then the </span><br><span class="line">use of address translation is transparent to any data access to the address.</span><br><span class="line"></span><br><span class="line">I_FHPPX</span><br><span class="line">The properties of data and unified caches are consistent with implementing the caches as physically-indexed, </span><br><span class="line">physically-tagged caches.</span><br><span class="line"></span><br><span class="line">D8.17.2 Instruction caches</span><br><span class="line"></span><br><span class="line">R_YXNGL &amp; R_LYZYY</span><br><span class="line">If all instruction fetches to an address do not use mismatched memory attributes, then the use of address </span><br><span class="line">translation is transparent to any instruction fetch to the address.</span><br></pre></td></tr></table></figure>

<p>在這個情況下cache就像是PIPT一樣，不會有不同VA造成的coherency問題，ordering方面也不會有問題，因為exception level切換屬於一種context synchronization event，保證了guest與host存取記憶體的順序。不過，因為instruction cache與data cache是沒有硬體coherent保證的，KVM在重新啟動vCPU之前必須要invalidate instruction cache。</p>
<p>第二，如果guest的memory access attributes與host不同，其實也不會有問題，即使有以下敘述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">B2.15.1.2 Non-shareable Normal memory</span><br><span class="line">A location in Normal memory with the Non-shareable attribute does not require the hardware to make data accesses </span><br><span class="line">by different observers coherent, unless the memory is Non-cacheable. For a Non-shareable location, if other </span><br><span class="line">observers share the memory system, software must use cache maintenance instructions, if the presence of caches </span><br><span class="line">might lead to coherency issues when communicating between the observers. This cache maintenance requirement </span><br><span class="line">is in addition to the barrier operations that are required to ensure memory ordering.</span><br></pre></td></tr></table></figure>

<p>host已知會使用inner cacheable, inner shareable，給guest的stage 2會也是inner shareable，所以guest最終使用的不會是non-shareable，所以也不會造成coherency問題，stage 1和stage 2 shareability合併的方式參照如下:</p>
<img src="/cache/image.png" class="">

<img src="/cache/image1.png" class="">

<p>那既然host與guest都是使用inner shareable，可以看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B2.15.1.1.1 Shareable, Inner Shareable, and Outer Shareable Normal memory</span><br><span class="line">Each Inner Shareability domain contains a set of observers that are data coherent for each member of that set for </span><br><span class="line">data accesses with the Inner Shareable attribute made by any member of that set.</span><br></pre></td></tr></table></figure>

<p>妥妥的，還是要flush instruction cache就是了</p>
<p>這邊沒有討論cacheability是因為by definition問題就說host與guest都使用cache存取了，所以一定是inner cacheable，畢竟一個作業系統是被預期跑在同一個inner shareability domain中的。</p>
<p>釐清一下，以下敘述所說需要cache maintenance是在有任意cacheability的情況，而現在guest &amp; host都是inner cacheable所以沒問題</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D8.17.3 Cache maintenance requirements due to changing memory region attributes</span><br><span class="line">The behaviors caused by mismatched memory attributes mean that if any of the following changes are made to the </span><br><span class="line">Inner Cacheability or Outer Cacheability attributes in translation table entries, then software is required to ensure </span><br><span class="line">that any cached copies of affected locations are removed from the caches, typically by cleaning and invalidating the </span><br><span class="line">locations from the cache levels that might hold copies of the locations affected by the attribute change:</span><br><span class="line">• A change from Write-Back to Write-Through.</span><br><span class="line">• A change from Write-Back to Non-cacheable.</span><br><span class="line">• A change from Write-Through to Non-cacheable.</span><br><span class="line">• A change from Write-Through to Write-Back.</span><br></pre></td></tr></table></figure>

<h3 id="問題2"><a href="#問題2" class="headerlink" title="問題2"></a>問題2</h3><p>這個就是mailing list上主要在討論的狀況，那也確實會發生，我在上面貼的mailing list那一段中講到之所以把stage 2給unmap掉是因為如此一來guest在重新執行的時候就會不斷的stage 2 page fault，而KVM在處理page fault時會使用VA來clean + invalidate cache to PoC，而在做此cache maintenance時:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D7.5.9.5 Effects of instructions that operate by VA to the PoC</span><br><span class="line">For Normal memory that is not Inner Non-cacheable, Outer Non-cacheable, cache maintenance instructions that </span><br><span class="line">operate by VA to the PoC must affect the caches of other PEs in the shareability domain described by the shareability </span><br><span class="line">attributes of the VA supplied with the instruction.</span><br></pre></td></tr></table></figure>

<p>也就是說所有CPU只要使用inner&#x2F;non shareable都會看到clean + invalidate的效果<del>(因為沒有non shareable的情況)</del></p>
<p>那一定要unmap嗎? 不能只clean + invalidate嗎? 我猜想只是這樣可以達到lazy cache maintenance的效果，兩個做法要付出的work如下：</p>
<p>unmap:</p>
<ul>
<li><p>爬整個guest s2並且清空stage 2 page tables</p>
</li>
<li><p>guest每存取一個page就page fault並且clean + invalidate</p>
</li>
</ul>
<p>clean + invalidate</p>
<ul>
<li>爬整個guest s2並且為整個VA做clean + invalidate</li>
</ul>
<p>究竟怎樣是比較划算也是個有趣的問題，不過我猜，當時選擇unmap的其中一個原因是實作比較簡單XD</p>
<h2 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h2><ul>
<li><p>Linux假設其控制的所有CPU均處於同一個inner shareability domain，ARM架構也做此假設</p>
</li>
<li><p>Linux使用的normal memory attributes為Inner Shareable, Inner Write-Back Cacheable Non-transient Outer Write-Back Cacheable Non-transient</p>
</li>
<li><p>device memory不會被緩存到cache中</p>
</li>
<li><p>在有stage 2 translation的情形之下，stage 1 translation的attributes (guest控制)會和KVM控制的stage 2 translation attributes合併</p>
</li>
</ul>
<h2 id="相關的ARM-Architecture-Reference-Manual章節"><a href="#相關的ARM-Architecture-Reference-Manual章節" class="headerlink" title="相關的ARM Architecture Reference Manual章節"></a>相關的ARM Architecture Reference Manual章節</h2><ul>
<li><p>B2.12 Caches and memory hierarchy</p>
</li>
<li><p>B2.15 Memory types and attributes</p>
</li>
<li><p>B2.16 Mismatched memory attributes</p>
</li>
<li><p>D7.5 Cache support</p>
</li>
<li><p>D8.2.12 The effects of disabling an address translation stage</p>
</li>
<li><p>D8.6 Memory region attributes</p>
</li>
<li><p>D8.17 Caches</p>
</li>
</ul>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%80%E5%80%8B%E5%9C%A8%E8%AE%80code%E9%81%87%E5%88%B0%E7%9A%84%E7%96%91%E5%95%8F"><span class="top-box-text">一個在讀code遇到的疑問</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Mailing-List%E6%80%8E%E9%BA%BC%E8%AA%AA"><span class="top-box-text">Mailing List怎麼說</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%88%86%E6%9E%90"><span class="top-box-text">分析</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%95%8F%E9%A1%8C1"><span class="top-box-text">問題1</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%95%8F%E9%A1%8C2"><span class="top-box-text">問題2</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AD%98"><span class="top-box-text">背景知識</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%9B%B8%E9%97%9C%E7%9A%84ARM-Architecture-Reference-Manual%E7%AB%A0%E7%AF%80"><span class="top-box-text">相關的ARM Architecture Reference Manual章節</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/casting_en/">
          <h3 class="post-title">
            Next: Casting a `char` to an `unsigned int` sign extends
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

