<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>Memory Barriers 筆記</title>
<meta name="google-site-verification" content="CmjL_aZ8fDb2ZxqOct5raymSCyinEt7dd7JeIro6eig" />
<meta name="keywords" content="Memory Barriers 筆記, blog keywords">
<meta name="description" content="本篇內容來自Paul E. McKenney的perfbook Appendix C “Why Memory Barriers”以及蜗窝科技網誌上的翻譯，快速地讀完一次之後覺得基本的原理了解了，不過說到細節還是有很多需要釐清的部分，所以想用">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>





  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://rhythm16.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://rhythm16.github.io">
        <h1 class="site-title">rhythm16.github.io</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        Home
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        Categories
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        Archives
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Memory Barriers 筆記</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2021-09-27</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/memory-barriers/">
              memory barriers
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>本篇內容來自Paul E. McKenney的<a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook">perfbook</a> Appendix C “Why Memory Barriers”以及蜗窝科技網誌上的<a target="_blank" rel="noopener" href="http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html">翻譯</a>，快速地讀完一次之後覺得基本的原理了解了，不過說到細節還是有很多需要釐清的部分，所以想用自己的方式寫下來。內容會比原文少非常多，要完整的學習的話建議閱讀原文。<br>Ascii art generated by <a target="_blank" rel="noopener" href="https://asciiflow.com/">asciiflow</a>.</p>
<h2 id="Stores-有時候很慢"><a href="#Stores-有時候很慢" class="headerlink" title="Stores 有時候很慢"></a>Stores 有時候很慢</h2><p>這是對一個SMP系統的簡略想像:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐          ┌───────┐</span><br><span class="line">│ CPU 0 │          │ CPU 1 │</span><br><span class="line">└───┬───┘          └───┬───┘</span><br><span class="line">┌───┴───┐          ┌───┴───┐</span><br><span class="line">│ CACHE │          │ CACHE │</span><br><span class="line">└───┬───┘          └───┬───┘</span><br><span class="line">    │   INTERCONNECT   │</span><br><span class="line">    └────────┬─────────┘</span><br><span class="line">             │</span><br><span class="line">         ┌───┴────┐</span><br><span class="line">         │ MEMORY │</span><br><span class="line">         └────────┘</span><br></pre></td></tr></table></figure>
<p>如果CPU0想要寫一個狀態是shared的cache line，必須發送一個invalidate訊號到interconnect上，再等其他所有CPU回傳invalidate acknowledge，如果其他的CPU cache很忙碌，這可能會讓CPU0 stall很久。</p>
<h2 id="Store-Buffer-and-Store-Forwarding"><a href="#Store-Buffer-and-Store-Forwarding" class="headerlink" title="Store Buffer and Store Forwarding"></a>Store Buffer and Store Forwarding</h2><p>為了增加速度，CPU設計師增加了store buffer，把即將要寫的內容先存起來，等到所有的invalidate acknowledge都拿到了再寫進cache中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐          ┌───────┐</span><br><span class="line">│ CPU 0 │          │ CPU 1 │</span><br><span class="line">└─┬──┬──┘          └─┬──┬──┘</span><br><span class="line">  │ ┌┴─────┐         │ ┌┴─────┐</span><br><span class="line">  │ │STORE │         │ │STORE │</span><br><span class="line">  │ │BUFFER│         │ │BUFFER│</span><br><span class="line">  │ └┬─────┘         │ └┬─────┘</span><br><span class="line">┌─┴──┴──┐          ┌─┴──┴──┐</span><br><span class="line">│ CACHE │          │ CACHE │</span><br><span class="line">└───┬───┘          └───┬───┘</span><br><span class="line">    │   INTERCONNECT   │</span><br><span class="line">    └─────────┬────────┘</span><br><span class="line">          ┌───┴────┐</span><br><span class="line">          │ MEMORY │</span><br><span class="line">          └────────┘</span><br></pre></td></tr></table></figure>
<p>如此一來CPU就不用等所有invalidate acknowledge到，只要先寫進store buffer就可以繼續執行接下來的指令了。不過這也會有一些問題:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* all variables start with 0 */</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = a + <span class="number">1</span>;</span><br><span class="line">assert(b == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>assert有可能不會過，步驟如下:</p>
<ol>
<li>CPU0發送read invalidate a</li>
<li>CPU0 把a &#x3D; 1寫進store buffer</li>
<li>CPU1回傳a的值並invalidate自己的cache line</li>
<li>CPU0從CPU1得到a &#x3D; 0的值，並放在cache中</li>
<li>CPU0在沒有觀察store buffer的情況下執行b &#x3D; a + 1</li>
<li>b最終的值&#x3D;1</li>
</ol>
<p>這個問題硬體可解，解法就是CPU0在做read的時候必須觀察自己的store buffer是否有新的值，也就是所謂的store forwarding。</p>
<h2 id="Store-Buffers-and-Memory-Barriers"><a href="#Store-Buffers-and-Memory-Barriers" class="headerlink" title="Store Buffers and Memory Barriers"></a>Store Buffers and Memory Barriers</h2><p>看題目:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* all variables start with 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zero</span><span class="params">()</span> <span class="comment">/* CPU 0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">one</span><span class="params">()</span> <span class="comment">/* CPU 1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在假設CPU0的cache line有b缺a，CPU1有a缺b<br>assert也有可能不會過，步驟如下:</p>
<ol>
<li>CPU1沒有b，所以發送read b</li>
<li>CPU0沒有a，所以發送read invalidate a並把a &#x3D; 1寫進store buffer</li>
<li>CPU0執行b &#x3D; 1</li>
<li>CPU1收到b &#x3D; 1</li>
<li>CPU1跳出迴圈執行assert，fail</li>
<li>CPU1現在才收到read invalidate a</li>
</ol>
<p>問題出在CPU0傳的read invalidate a和針對CPU1的read b response順序錯了，導致CPU1先看到b的更新才看到a的更新，至於順序為什麼錯，我能想到的原因有:</p>
<ul>
<li>read response優先於read invalidate</li>
<li>cache優先於store buffer</li>
<li>interconnect的硬體設計</li>
<li>compiler reordering (但這篇文章不是討論這個)</li>
</ul>
<p>這樣的問題沒有辦法透過硬體直接解決，因為硬體沒有辦法知道a和b之間的依賴關係。為了解決這樣的問題CPU提供了所謂的memory barriers讓軟體使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* all variables start with 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zero</span><span class="params">()</span> <span class="comment">/* CPU 0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">one</span><span class="params">()</span> <span class="comment">/* CPU 1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一來，<code>smp_mb()</code>執行之後在store buffer中的所有entry(包含a &#x3D; 1)會被註記，CPU在所有被標記的store完成之前不會讓後續的store顯示在cache中。b &#x3D; 1也會被存在store buffer中，即使b的cache line對於CPU0是Modified或Exclusive。<br>還是列一下步驟:</p>
<ol>
<li>CPU1沒有b，所以發送read b</li>
<li>CPU0沒有a，所以發送read invalidate a並把a &#x3D; 1寫進store buffer</li>
<li><code>smp_mb()</code>，CPU0 store buffer中的a &#x3D; 1被標註</li>
<li>CPU0執行b &#x3D; 1，而因為store buffer中有被標註的entry所以也把b &#x3D; 1放入store buffer</li>
<li>CPU0把b的原始值(0)傳給CPU1，此時雙方的b處於shared狀態</li>
<li>CPU1把自己的a給invalidate並傳送invalidate acknowledge給CPU0</li>
<li>CPU0收到invalidate acknowledge，a的狀態為Exclusive</li>
<li>CPU0把store buffer的a &#x3D; 1寫進cache，a狀態變為Modified</li>
<li>CPU0把store buffer的b &#x3D; 1寫進cache，b狀態從shared變為modified，並發送b的invalidate給CPU1</li>
<li>CPU1收到b的invalidate，發送invalidate acknowledge，然後執行<code>while (b == 0)</code>時發現自己沒有b(invalidated)便發送b的read</li>
<li>CPU0把b傳給CPU1，狀態改為shared</li>
<li>CPU1執行assert，再向CPU0要a</li>
<li>assert通過</li>
</ol>
<h2 id="Invalidate-Queues"><a href="#Invalidate-Queues" class="headerlink" title="Invalidate Queues"></a>Invalidate Queues</h2><p>Store Buffers存在的原因是等待所有CPU的invalidate acknowledge太慢了，所以先把要寫的東西放在一個地方，然後繼續執行下面的指令。那有沒有可能讓其他CPU的invalidate acknowledge回傳得快一點?<br>一個思考的方向是invalidate acknowledge只是說明「我知道我這個cache line不能用了」，並不一定要當場把那個cache line給invalidate掉，所以就誕生了invalidate queue，把需要invalidate的cache line的資訊給暫時存在一個queue上，就馬上回傳invalidate queue。如此一來即使cache正在忙碌，也能快速地回覆invalidate acknowledge給其他的CPU，讓他們繼續執行，而自己只需要在往外廣播coherency protocol的訊息時確認廣播的cache line不在invalidate queue中，因為cache line C如果在invalidate queue中，必須先處理才能向外面的interconnect發送關於C的訊息，不然不合理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> ┌───────┐          ┌───────┐</span><br><span class="line"> │ CPU 0 │          │ CPU 1 │</span><br><span class="line"> └─┬──┬──┘          └─┬──┬──┘</span><br><span class="line">   │ ┌┴─────┐         │ ┌┴─────┐</span><br><span class="line">   │ │STORE │         │ │STORE │</span><br><span class="line">   │ │BUFFER│         │ │BUFFER│</span><br><span class="line">   │ └┬─────┘         │ └┬─────┘</span><br><span class="line"> ┌─┴──┴──┐          ┌─┴──┴──┐</span><br><span class="line"> │ CACHE │          │ CACHE │</span><br><span class="line"> └───┬───┘          └───┬───┘</span><br><span class="line">┌────┴─────┐       ┌────┴─────┐</span><br><span class="line">│INVALIDATE│       │INVALIDATE│</span><br><span class="line">│  QUEUE   │       │  QUEUE   │</span><br><span class="line">└────┬─────┘       └────┬─────┘</span><br><span class="line">     │   INTERCONNECT   │</span><br><span class="line">     └─────────┬────────┘</span><br><span class="line">           ┌───┴────┐</span><br><span class="line">           │ MEMORY │</span><br><span class="line">           └────────┘</span><br></pre></td></tr></table></figure>
<p>好事不成雙，這樣的設計也會出錯，同樣的例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* all variables start with 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zero</span><span class="params">()</span> <span class="comment">/* CPU 0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">one</span><span class="params">()</span> <span class="comment">/* CPU 1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>CPU1沒有b，所以發送read b</li>
<li>CPU0沒有a，所以發送read invalidate a並把a &#x3D; 1寫進store buffer</li>
<li><code>smp_mb()</code>，CPU0 store buffer中的a &#x3D; 1被標註</li>
<li>CPU0執行b &#x3D; 1，而因為store buffer中有被標註的entry所以也把b &#x3D; 1放入store buffer</li>
<li>CPU1收到read invalidate a，放進invalidate queue，馬上回覆invalidate acknowledge</li>
<li>CPU0收到a的invalidate acknowledge，依序把a &#x3D; 1，b &#x3D; 1寫進cache</li>
<li>CPU0把b的新值1傳給CPU1</li>
<li>CPU1執行<code>while (b == 0)</code>，跳出迴圈</li>
<li>CPU1執行<code>assert(a == 1)</code>，失敗</li>
<li>CPU1現在才有空處理invalidate queue，發現a處於invalidate狀態，不過錯誤已經產生</li>
</ol>
<blockquote>
<p>read的時候會觀察store buffer，避免自己寫自己沒看到，不過不會觀察invalidate queue，以增加效能</p>
</blockquote>
<p>增加memory barrier可以解決這樣的錯誤:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* all variables start with 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zero</span><span class="params">()</span> <span class="comment">/* CPU 0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">one</span><span class="params">()</span> <span class="comment">/* CPU 1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>CPU1沒有b，所以發送read b</li>
<li>CPU0沒有a，所以發送read invalidate a並把a &#x3D; 1寫進store buffer</li>
<li><code>smp_mb()</code>，CPU0 store buffer中的a &#x3D; 1被標註</li>
<li>CPU0執行b &#x3D; 1，而因為store buffer中有被標註的entry所以也把b &#x3D; 1放入store buffer</li>
<li>CPU1收到read invalidate a，放進invalidate queue，馬上回覆invalidate acknowledge</li>
<li>CPU0收到a的invalidate acknowledge，依序把a &#x3D; 1，b &#x3D; 1寫進cache</li>
<li>CPU0把b的新值1傳給CPU1</li>
<li>CPU1執行<code>while (b == 0)</code>，跳出迴圈</li>
<li><code>smp_mb()</code>，在invalidate queue中的invalidate a被標註</li>
<li>CPU1中的a被invalidate，無法執行<code>assert(a == 1)</code>，發送read a</li>
<li>CPU1得到a的新值，assert通過</li>
</ol>
<h2 id="Read-and-Write-Memory-Barriers"><a href="#Read-and-Write-Memory-Barriers" class="headerlink" title="Read and Write Memory Barriers"></a>Read and Write Memory Barriers</h2><p>前面所使用的<code>smp_mb()</code>會把store buffer和invadate queue中的entry都加上標註，這有時候是不需要的，<code>zero()</code>沒有讀東西，用不到invalidate queue，<code>one()</code>沒有寫東西，用不到store buffer，所以有效果比較弱的read memory barriers，對應到invalidate queue加標註和write memory barriers，對應到store buffer加標註，前面的例子可以改為:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* all variables start with 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zero</span><span class="params">()</span> <span class="comment">/* CPU 0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_wmb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">one</span><span class="params">()</span> <span class="comment">/* CPU 1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    smp_rmb();</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Stores-%E6%9C%89%E6%99%82%E5%80%99%E5%BE%88%E6%85%A2"><span class="top-box-text">Stores 有時候很慢</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Store-Buffer-and-Store-Forwarding"><span class="top-box-text">Store Buffer and Store Forwarding</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Store-Buffers-and-Memory-Barriers"><span class="top-box-text">Store Buffers and Memory Barriers</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Invalidate-Queues"><span class="top-box-text">Invalidate Queues</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Read-and-Write-Memory-Barriers"><span class="top-box-text">Read and Write Memory Barriers</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/make/">
          <h3 class="post-title">
            Next: Makefile Notes
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

