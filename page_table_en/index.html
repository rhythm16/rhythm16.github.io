<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>Linux ARM64 `__create_pgd_mapping` Analysis</title>
<meta name="google-site-verification" content="CmjL_aZ8fDb2ZxqOct5raymSCyinEt7dd7JeIro6eig" />
<meta name="keywords" content="Linux ARM64 `__create_pgd_mapping` Analysis, blog keywords">
<meta name="description" content="
Linux version: v6.0
Architecture: ARMv8

IntroductionMemory mapping is probably the toughest part to understand in the ">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>





  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://rhythm16.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://rhythm16.github.io">
        <h1 class="site-title">rhythm16.github.io</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        Home
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        Categories
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        Archives
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Linux ARM64 `__create_pgd_mapping` Analysis</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-02-13</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/page-tables/">
              page tables
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>Linux version: v6.0</p>
<p>Architecture: ARMv8</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Memory mapping is probably the toughest part to understand in the boot flow of the Linux kernel, this is partly because the code setting up the memory mappings is also running under a certain mapping. Therefore other than understanding what the code is doing, knowing what the current mapping is is also important. The code may also alter the memory mapping in several ways as well. The variables complicates matters even more, contains sometimes physical addresses, sometimes virtual addresses.</p>
<p><code>__create_pgd_mapping</code> is introduced in this article, it serves as a helper function to create page table mappings between virtual and physical address ranges. Instead of how the function is used, its implementation is discussed here.</p>
<h2 id="create-pgd-mapping-Execution-Context"><a href="#create-pgd-mapping-Execution-Context" class="headerlink" title="__create_pgd_mapping Execution Context"></a><code>__create_pgd_mapping</code> Execution Context</h2><p>Let’s talk a little about the execution context of <code>__create_pgd_mapping</code> before diving into the implementation. This function is mostly used early during boot, MMU has been enabled, the pgd is (mostly) <code>init_pg_dir</code> , linear mapping may not be created yet so it is not used in the function, the fixmap is created other than the actual level 3 entries, the kernel is running at high address.</p>
<h2 id="create-pgd-mapping-Function-Signature"><a href="#create-pgd-mapping-Function-Signature" class="headerlink" title="__create_pgd_mapping Function Signature"></a><code>__create_pgd_mapping</code> Function Signature</h2><p><code>__create_pgd_mapping</code> ‘s function signature is as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __create_pgd_mapping(<span class="type">pgd_t</span> *pgdir, <span class="type">phys_addr_t</span> phys,</span><br><span class="line">                                 <span class="type">unsigned</span> <span class="type">long</span> virt, <span class="type">phys_addr_t</span> size,</span><br><span class="line">                                 <span class="type">pgprot_t</span> prot,</span><br><span class="line">                                 <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span><br><span class="line">                                 <span class="type">int</span> flags);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>pgdir</code> : virtual address of the root of the page table to create the mapping</p>
</li>
<li><p><code>phys</code> : physical address of the start of the range to map</p>
</li>
<li><p><code>virt</code> : virtual address of the start of the range to map</p>
</li>
<li><p><code>size</code> : size of the range to map</p>
</li>
<li><p><code>prot</code> : attributes of the mapping</p>
</li>
<li><p><code>pgtable_alloc</code> : the memory allocation function to be used during the creation of the mapping</p>
</li>
<li><p><code>flags</code> : some flags to dictate the behavior when creating the mapping</p>
</li>
</ul>
<h2 id="create-pgd-mapping-Implementation"><a href="#create-pgd-mapping-Implementation" class="headerlink" title="__create_pgd_mapping Implementation"></a><code>__create_pgd_mapping</code> Implementation</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __create_pgd_mapping(<span class="type">pgd_t</span> *pgdir, <span class="type">phys_addr_t</span> phys,</span><br><span class="line">                                 <span class="type">unsigned</span> <span class="type">long</span> virt, <span class="type">phys_addr_t</span> size,</span><br><span class="line">                                 <span class="type">pgprot_t</span> prot,</span><br><span class="line">                                 <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span><br><span class="line">                                 <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">        mutex_lock(&amp;fixmap_lock);</span><br><span class="line">        __create_pgd_mapping_locked(pgdir, phys, virt, size, prot,</span><br><span class="line">                                    pgtable_alloc, flags);</span><br><span class="line">        mutex_unlock(&amp;fixmap_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is trivial, take the fixmap lock and call <code>__create_pgd_mapping_locked</code></p>
<h3 id="create-pgd-mapping-locked"><a href="#create-pgd-mapping-locked" class="headerlink" title="__create_pgd_mapping_locked"></a><code>__create_pgd_mapping_locked</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __create_pgd_mapping_locked(<span class="type">pgd_t</span> *pgdir, <span class="type">phys_addr_t</span> phys,</span><br><span class="line">                                        <span class="type">unsigned</span> <span class="type">long</span> virt, <span class="type">phys_addr_t</span> size,</span><br><span class="line">                                        <span class="type">pgprot_t</span> prot,</span><br><span class="line">                                        <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span><br><span class="line">                                        <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> addr, end, next;</span><br><span class="line">        <span class="comment">// calculate the address of the pgd entry to translate virt</span></span><br><span class="line">        <span class="type">pgd_t</span> *pgdp = pgd_offset_pgd(pgdir, virt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the virtual and physical address don&#x27;t have the same offset</span></span><br><span class="line"><span class="comment">         * within a page, we cannot map the region as the caller expects.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (WARN_ON((phys ^ virt) &amp; ~PAGE_MASK))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// round down phys to size of a page</span></span><br><span class="line">        phys &amp;= PAGE_MASK;</span><br><span class="line">        <span class="comment">// addr is a local variable recording the virtual address to be mapped now,</span></span><br><span class="line">        <span class="comment">// it is initialized to virt rounded down to size of a page</span></span><br><span class="line">        addr = virt &amp; PAGE_MASK;</span><br><span class="line">        <span class="comment">// end is the end of the virtual address range to be mapped</span></span><br><span class="line">        end = PAGE_ALIGN(virt + size);</span><br><span class="line">        <span class="comment">// this loop creates mapping for a pgd entry in one iteration,</span></span><br><span class="line">        <span class="comment">// e.g. a 512GB range for the 48bits VA, 4K case</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// pgd_addr_end returns (addr + range for one pgd entry), or end, </span></span><br><span class="line">                <span class="comment">// depending on which is smaller</span></span><br><span class="line">                next = pgd_addr_end(addr, end);</span><br><span class="line">                <span class="comment">// send current pgdp,</span></span><br><span class="line">                <span class="comment">// addr(start of the VA of this iteration)</span></span><br><span class="line">                <span class="comment">// next(end of the VA of this iteration)</span></span><br><span class="line">                <span class="comment">// phys(start of the PA of this iteration)</span></span><br><span class="line">                <span class="comment">// prot, pgtable_alloc, flag to the function handling the pud level</span></span><br><span class="line">                alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc,</span><br><span class="line">                               flags);</span><br><span class="line">                <span class="comment">// alloc_init_pud creates mapping for addr~next, so step forward</span></span><br><span class="line">                <span class="comment">// phys an amount of next - addr after return</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// process the next pgd entry, also step forward addr, end if addr == end</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pgdp++, addr = next, addr != end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="alloc-init-pud"><a href="#alloc-init-pud" class="headerlink" title="alloc_init_pud"></a><code>alloc_init_pud</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_init_pud</span><span class="params">(<span class="type">pgd_t</span> *pgdp, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> end,</span></span><br><span class="line"><span class="params">                           <span class="type">phys_addr_t</span> phys, <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                           <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="type">pud_t</span> *pudp;</span><br><span class="line">        <span class="comment">// p4d is the extra level used in five level paging, if fewer than five levels</span></span><br><span class="line">        <span class="comment">// p4dp = pgdp, assume four level paging for now</span></span><br><span class="line">        <span class="type">p4d_t</span> *p4dp = p4d_offset(pgdp, addr);</span><br><span class="line">        <span class="comment">// assume p4d = pgd here</span></span><br><span class="line">        <span class="type">p4d_t</span> p4d = READ_ONCE(*p4dp);</span><br><span class="line">        <span class="comment">// if the entry pointed to by pgdp is none</span></span><br><span class="line">        <span class="keyword">if</span> (p4d_none(p4d)) &#123;</span><br><span class="line">                <span class="comment">// prepare an entry pointing to a table (pud), and not executable in</span></span><br><span class="line">                <span class="comment">// EL0</span></span><br><span class="line">                <span class="type">p4dval_t</span> p4dval = P4D_TYPE_TABLE | P4D_TABLE_UXN;</span><br><span class="line">                <span class="type">phys_addr_t</span> pud_phys;</span><br><span class="line">                <span class="comment">// if the flags contains NO_EXEC_MAPPING</span></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; NO_EXEC_MAPPINGS)</span><br><span class="line">                        <span class="comment">// then not executable in EL1 as well</span></span><br><span class="line">                        p4dval |= P4D_TABLE_PXN;</span><br><span class="line">                BUG_ON(!pgtable_alloc);</span><br><span class="line">                <span class="comment">// allocate a pud page using the function passed in</span></span><br><span class="line">                pud_phys = pgtable_alloc(PUD_SHIFT);</span><br><span class="line">                <span class="comment">// populate the pgd entry with the physical address of the pud page</span></span><br><span class="line">                <span class="comment">// and the attributes in p4dval</span></span><br><span class="line">                __p4d_populate(p4dp, pud_phys, p4dval);</span><br><span class="line">                <span class="comment">// read the entry out to check later</span></span><br><span class="line">                p4d = READ_ONCE(*p4dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// here the p4d has to be a valid pgd entry</span></span><br><span class="line">        BUG_ON(p4d_bad(p4d));</span><br><span class="line">        <span class="comment">// this line of code is tricky, it maps the pud page to a fixed virtual address</span></span><br><span class="line">        <span class="comment">// this is necessary because we read a pgd entry from pgdp, which contains the</span></span><br><span class="line">        <span class="comment">// pud page&#x27;s physical address, so we must map the pud page to a virtual</span></span><br><span class="line">        <span class="comment">// address before we can actually access the pud page, here the fixmap mechanism</span></span><br><span class="line">        <span class="comment">// is used to map the pud page</span></span><br><span class="line">        <span class="comment">// pudp = the virtual address of the pud entry used to translate addr</span></span><br><span class="line">        pudp = pud_set_fixmap_offset(p4dp, addr);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// read the pud entry</span></span><br><span class="line">                <span class="type">pud_t</span> old_pud = READ_ONCE(*pudp);</span><br><span class="line">                <span class="comment">// next = ((addr + range of one pud entry), or end, whichever is smaller)</span></span><br><span class="line">                next = pud_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * For 4K granule only, attempt to put down a 1GB block</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// if it is possible doing a section mapping (1GB)</span></span><br><span class="line">                <span class="keyword">if</span> (pud_sect_supported() &amp;&amp;</span><br><span class="line">                   <span class="comment">// the current range to map is precisely 1GB and is aligned</span></span><br><span class="line">                   ((addr | next | phys) &amp; ~PUD_MASK) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    <span class="comment">// also the flag does not forbid a section(block) mapping</span></span><br><span class="line">                    (flags &amp; NO_BLOCK_MAPPINGS) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// map the 1GB page here</span></span><br><span class="line">                        pud_set_huge(pudp, phys, prot);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * After the PUD entry has been populated once, we</span></span><br><span class="line"><span class="comment">                         * only allow updates to the permission attributes.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        BUG_ON(!pgattr_change_is_safe(pud_val(old_pud),</span><br><span class="line">                                                      READ_ONCE(pud_val(*pudp))));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// pudp: the virtual address of the current pud entry</span></span><br><span class="line">                        <span class="comment">// addr: the starting virtual address of the range to map</span></span><br><span class="line">                        <span class="comment">// next: the ending virtual address of the range to map</span></span><br><span class="line">                        <span class="comment">// phys: the physical address of the range to map</span></span><br><span class="line">                        <span class="comment">// alloc_init_cont_pmd is responsible for mapping addr~next</span></span><br><span class="line">                        alloc_init_cont_pmd(pudp, addr, next, phys, prot,</span><br><span class="line">                                            pgtable_alloc, flags);</span><br><span class="line">                        BUG_ON(pud_val(old_pud) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                               pud_val(old_pud) != READ_ONCE(pud_val(*pudp)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// here the mapping of addr~next is completed, so step forward phys</span></span><br><span class="line">                <span class="comment">// by next - addr</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// go on to the next pud entry, and step forward addr, finish if addr == end</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pudp++, addr = next, addr != end);</span><br><span class="line">        <span class="comment">// clear the pud page map created earlier</span></span><br><span class="line">        pud_clear_fixmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here requires some explanation, the call chain looks like this:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__create_pgd_mapping</span><br><span class="line">--&gt; __create_pgd_mapping_locked</span><br><span class="line">    --&gt; alloc_init_pud</span><br><span class="line">        // the following <span class="built_in">functions</span> are explained below</span><br><span class="line">        --&gt; alloc_init_cont_pmd</span><br><span class="line">            --&gt; init_pmd</span><br><span class="line">                --&gt; alloc_init_cont_pte</span><br><span class="line">                    --&gt; init_pte </span><br></pre></td></tr></table></figure>

<p>The analysis up to now explained that:</p>
<p><code>__create_pgd_mapping_locked</code> is responsible for filling in the pgd page</p>
<p><code>alloc_init_pud</code> is responsible for filling in the pud page</p>
<p>Then why do pmd and pte each requires two functions to handle them? The answer is that in ARMv8 the page table entries contain a contiguous bit, simply put, if serveral continuous page table entries (continuous virtual address range) is mapped to a contiguous physical address range, software can set this bit in the page table entries to achieve better TLB performance. <code>alloc_init_cont_pmd</code> and <code>alloc_init_cont_pte</code> tries to use the contiguous bit base on the address ranges passed in, and <code>init_pmd</code> and <code>init_pte</code> is responsible for the actual filling of the pmd and pte pages.</p>
<h3 id="alloc-init-cont-pmd"><a href="#alloc-init-cont-pmd" class="headerlink" title="alloc_init_cont_pmd"></a><code>alloc_init_cont_pmd</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_init_cont_pmd</span><span class="params">(<span class="type">pud_t</span> *pudp, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">long</span> end, <span class="type">phys_addr_t</span> phys,</span></span><br><span class="line"><span class="params">                                <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                                <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>), <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="comment">// read the pud entry</span></span><br><span class="line">        <span class="type">pud_t</span> pud = READ_ONCE(*pudp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Check for initial section mappings in the pgd/pud.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// we shouldn&#x27;t be called it the pud is a section mapping, so BUG</span></span><br><span class="line">        BUG_ON(pud_sect(pud));</span><br><span class="line">        <span class="comment">// if this entry is none</span></span><br><span class="line">        <span class="keyword">if</span> (pud_none(pud)) &#123;</span><br><span class="line">                <span class="comment">// prepare an entry pointing to a table (pmd), and not executable in</span></span><br><span class="line">                <span class="comment">// EL0</span></span><br><span class="line">                <span class="type">pudval_t</span> pudval = PUD_TYPE_TABLE | PUD_TABLE_UXN;</span><br><span class="line">                <span class="type">phys_addr_t</span> pmd_phys;</span><br><span class="line">                <span class="comment">// if the flags contains NO_EXEC_MAPPING</span></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; NO_EXEC_MAPPINGS)</span><br><span class="line">                        <span class="comment">// then not executable in EL1 as well</span></span><br><span class="line">                        pudval |= PUD_TABLE_PXN;</span><br><span class="line">                BUG_ON(!pgtable_alloc);</span><br><span class="line">                <span class="comment">// allocate a pud page using the function passed in</span></span><br><span class="line">                pmd_phys = pgtable_alloc(PMD_SHIFT);</span><br><span class="line">                <span class="comment">// populate the pud entry with the physical address of the pud page</span></span><br><span class="line">                <span class="comment">// and the attributes in pudval</span></span><br><span class="line">                __pud_populate(pudp, pmd_phys, pudval);</span><br><span class="line">                <span class="comment">// read the entry out to check later</span></span><br><span class="line">                pud = READ_ONCE(*pudp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// here the pud has to be a valid pud entry</span></span><br><span class="line">        BUG_ON(pud_bad(pud));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">pgprot_t</span> __prot = prot;</span><br><span class="line">                <span class="comment">// next = ((addr + range of one pmd entry), or end, whichever is smaller)</span></span><br><span class="line">                next = pmd_cont_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* use a contiguous mapping if the range is suitably aligned */</span></span><br><span class="line">                <span class="comment">// check if the range addr~next is large enough and aligned for </span></span><br><span class="line">                <span class="comment">// contiguous mapping</span></span><br><span class="line">                <span class="keyword">if</span> ((((addr | next | phys) &amp; ~CONT_PMD_MASK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                    <span class="comment">// also the flag does not forbid a contiguous mapping</span></span><br><span class="line">                    (flags &amp; NO_CONT_MAPPINGS) == <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">// or the attributes with the contiguous bit</span></span><br><span class="line">                        __prot = __pgprot(pgprot_val(prot) | PTE_CONT);</span><br><span class="line">                <span class="comment">// call init_pmd to process the pmd page</span></span><br><span class="line">                init_pmd(pudp, addr, next, phys, __prot, pgtable_alloc, flags);</span><br><span class="line">                <span class="comment">// here the mapping of addr~next is completed, so step forward phys</span></span><br><span class="line">                <span class="comment">// by next - addr</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// step forward addr, break if addr == end</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (addr = next, addr != end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="init-pmd"><a href="#init-pmd" class="headerlink" title="init_pmd"></a><code>init_pmd</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pmd</span><span class="params">(<span class="type">pud_t</span> *pudp, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> end,</span></span><br><span class="line"><span class="params">                     <span class="type">phys_addr_t</span> phys, <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                     <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>), <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="type">pmd_t</span> *pmdp;</span><br><span class="line">        <span class="comment">// just like pud_set_fixmap_offset previously, read the physical address</span></span><br><span class="line">        <span class="comment">// of the pmd page from pudp, and map it to a fixed virtual address, then</span></span><br><span class="line">        <span class="comment">// return the virtual address in the pmd page that points to the entry</span></span><br><span class="line">        <span class="comment">// used when translating addr</span></span><br><span class="line">        pmdp = pmd_set_fixmap_offset(pudp, addr);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// read the pmd entry</span></span><br><span class="line">                <span class="type">pmd_t</span> old_pmd = READ_ONCE(*pmdp);</span><br><span class="line">                <span class="comment">// next = ((addr + range of one pmd entry), or end, whichever is smaller)</span></span><br><span class="line">                next = pmd_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* try section mapping first */</span></span><br><span class="line">                <span class="comment">// if the size of addr~next is a multiple of a pmd section (usually 2MB)</span></span><br><span class="line">                <span class="comment">// and is properly aligned</span></span><br><span class="line">                <span class="keyword">if</span> (((addr | next | phys) &amp; ~PMD_MASK) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    <span class="comment">// also the flags does not forbid section mapping</span></span><br><span class="line">                    (flags &amp; NO_BLOCK_MAPPINGS) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// create the huge page mapping</span></span><br><span class="line">                        pmd_set_huge(pmdp, phys, prot);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * After the PMD entry has been populated once, we</span></span><br><span class="line"><span class="comment">                         * only allow updates to the permission attributes.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        BUG_ON(!pgattr_change_is_safe(pmd_val(old_pmd),</span><br><span class="line">                                                      READ_ONCE(pmd_val(*pmdp))));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// for contiguous pte</span></span><br><span class="line">                        alloc_init_cont_pte(pmdp, addr, next, phys, prot,</span><br><span class="line">                                            pgtable_alloc, flags);</span><br><span class="line"></span><br><span class="line">                        BUG_ON(pmd_val(old_pmd) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                               pmd_val(old_pmd) != READ_ONCE(pmd_val(*pmdp)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// alloc_init_pud creates mapping for addr~next, so step forward</span></span><br><span class="line">                <span class="comment">// phys an amount of next - addr after return</span></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        <span class="comment">// go on to the next pmd entry, and step forward addr, finish if addr == end</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pmdp++, addr = next, addr != end);</span><br><span class="line">        <span class="comment">// clear the pmd page map created earlier</span></span><br><span class="line">        pmd_clear_fixmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following <code>alloc_init_cont_pte</code> and <code>init_pte</code> is pretty much the same as the pmd version, try to trace it yourself!</p>
<h3 id="alloc-init-cont-pte"><a href="#alloc-init-cont-pte" class="headerlink" title="alloc_init_cont_pte"></a><code>alloc_init_cont_pte</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_init_cont_pte</span><span class="params">(<span class="type">pmd_t</span> *pmdp, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">long</span> end, <span class="type">phys_addr_t</span> phys,</span></span><br><span class="line"><span class="params">                                <span class="type">pgprot_t</span> prot,</span></span><br><span class="line"><span class="params">                                <span class="type">phys_addr_t</span> (*pgtable_alloc)(<span class="type">int</span>),</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> next;</span><br><span class="line">        <span class="type">pmd_t</span> pmd = READ_ONCE(*pmdp);</span><br><span class="line"></span><br><span class="line">        BUG_ON(pmd_sect(pmd));</span><br><span class="line">        <span class="keyword">if</span> (pmd_none(pmd)) &#123;</span><br><span class="line">                <span class="type">pmdval_t</span> pmdval = PMD_TYPE_TABLE | PMD_TABLE_UXN;                                                                                                       </span><br><span class="line">                <span class="type">phys_addr_t</span> pte_phys;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; NO_EXEC_MAPPINGS)</span><br><span class="line">                        pmdval |= PMD_TABLE_PXN;</span><br><span class="line">                BUG_ON(!pgtable_alloc);</span><br><span class="line">                pte_phys = pgtable_alloc(PAGE_SHIFT);</span><br><span class="line">                __pmd_populate(pmdp, pte_phys, pmdval);</span><br><span class="line">                pmd = READ_ONCE(*pmdp);</span><br><span class="line">        &#125;</span><br><span class="line">        BUG_ON(pmd_bad(pmd));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">pgprot_t</span> __prot = prot;</span><br><span class="line"></span><br><span class="line">                next = pte_cont_addr_end(addr, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* use a contiguous mapping if the range is suitably aligned */</span></span><br><span class="line">                <span class="keyword">if</span> ((((addr | next | phys) &amp; ~CONT_PTE_MASK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                    (flags &amp; NO_CONT_MAPPINGS) == <span class="number">0</span>)</span><br><span class="line">                        __prot = __pgprot(pgprot_val(prot) | PTE_CONT);</span><br><span class="line"></span><br><span class="line">                init_pte(pmdp, addr, next, phys, __prot);</span><br><span class="line"></span><br><span class="line">                phys += next - addr;</span><br><span class="line">        &#125; <span class="keyword">while</span> (addr = next, addr != end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="init-pte"><a href="#init-pte" class="headerlink" title="init_pte"></a><code>init_pte</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_pte</span><span class="params">(<span class="type">pmd_t</span> *pmdp, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> end,</span></span><br><span class="line"><span class="params">                     <span class="type">phys_addr_t</span> phys, <span class="type">pgprot_t</span> prot)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pte_t</span> *ptep;</span><br><span class="line"></span><br><span class="line">        ptep = pte_set_fixmap_offset(pmdp, addr);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">pte_t</span> old_pte = READ_ONCE(*ptep);</span><br><span class="line">                <span class="comment">// this line actually does the work of writing the pte entry,</span></span><br><span class="line">                <span class="comment">// which is consisted of phys and prot, to the location pointed</span></span><br><span class="line">                <span class="comment">// to by ptep</span></span><br><span class="line">                set_pte(ptep, pfn_pte(__phys_to_pfn(phys), prot));</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * After the PTE entry has been populated once, we</span></span><br><span class="line"><span class="comment">                 * only allow updates to the permission attributes.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                BUG_ON(!pgattr_change_is_safe(pte_val(old_pte),</span><br><span class="line">                                              READ_ONCE(pte_val(*ptep))));</span><br><span class="line"></span><br><span class="line">                phys += PAGE_SIZE;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ptep++, addr += PAGE_SIZE, addr != end);</span><br><span class="line"></span><br><span class="line">        pte_clear_fixmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Introduction"><span class="top-box-text">Introduction</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#create-pgd-mapping-Execution-Context"><span class="top-box-text">__create_pgd_mapping Execution Context</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#create-pgd-mapping-Function-Signature"><span class="top-box-text">__create_pgd_mapping Function Signature</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#create-pgd-mapping-Implementation"><span class="top-box-text">__create_pgd_mapping Implementation</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#create-pgd-mapping-locked"><span class="top-box-text">__create_pgd_mapping_locked</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#alloc-init-pud"><span class="top-box-text">alloc_init_pud</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#alloc-init-cont-pmd"><span class="top-box-text">alloc_init_cont_pmd</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#init-pmd"><span class="top-box-text">init_pmd</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#alloc-init-cont-pte"><span class="top-box-text">alloc_init_cont_pte</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#init-pte"><span class="top-box-text">init_pte</span></a></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/page_table/">
          <h3 class="post-title">
            Next: Linux ARM64 `__create_pgd_mapping` 分析
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

