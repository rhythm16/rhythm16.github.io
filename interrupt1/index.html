<!DOCTYPE html>
<html lang="en">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>Linux中斷子系統簡介(1): 中斷處理流程的建立</title>
<meta name="google-site-verification" content="CmjL_aZ8fDb2ZxqOct5raymSCyinEt7dd7JeIro6eig" />
<meta name="keywords" content="Linux中斷子系統簡介(1): 中斷處理流程的建立, blog keywords">
<meta name="description" content="
Linux版本：v6.0
處理器架構：ARMv8

前言這幾週花了不少時間在看Linux到底是怎麼處理中斷的，在閱讀網路上前輩們介紹Linux中斷的blogs時總覺得細節都講得不錯，但大方向好難掌握住，我也是真的下去trace一遍才比較有">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/style/prism.css"/>





  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://rhythm16.github.io">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://rhythm16.github.io">
        <h1 class="site-title">rhythm16.github.io</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        Home
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        Categories
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        Archives
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Linux中斷子系統簡介(1): 中斷處理流程的建立</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-09-23</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Linux/">
              Linux
                
                  ，
                
              </a>
            
              <a href="/tags/ARMv8/">
              ARMv8
                
                  ，
                
              </a>
            
              <a href="/tags/interrupt/">
              interrupt
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>Linux版本：v6.0</p>
<p>處理器架構：ARMv8</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這幾週花了不少時間在看Linux到底是怎麼處理中斷的，在閱讀網路上前輩們介紹Linux中斷的blogs時總覺得細節都講得不錯，但大方向好難掌握住，我也是真的下去trace一遍才比較有感覺。這篇文章希望用另一個角度，以<em><strong>最快的速度</strong></em>帶過一遍中斷處理流程的建立與執行，達到初步理解整體架構的目的。我會先講解Linux處理中斷的一些關鍵概念，再使用一個真實的例子來說明這些概念怎麼對應到核心中真實的code。</p>
<p>這裡使用的例子是ARM64架構配合一個GICv2的中斷控制器建立IPI的情況，為了不讓整體描述過於發散&amp;過長導致理解混亂，這篇用了很case specific的方式來講述，從而有些細節不免被省略，文章最後會放一些沒有提到的概念，供各位深入研究。</p>
<blockquote>
<p>因為寫起來過長，文章計畫分成 中斷處理流程建立 與 中斷處理流程執行 兩篇</p>
</blockquote>
<h2 id="作業系統中斷極簡介紹"><a href="#作業系統中斷極簡介紹" class="headerlink" title="作業系統中斷極簡介紹"></a>作業系統中斷極簡介紹</h2><p>在說明Linux如何處理中斷之前，當然要知道中斷是個什麼東西。中斷基本上來說就是CPU核心的一個針腳被外界改變電位，內部電路感知之後開始相應的處理來響應這件事。在現代大部分的電腦系統中，有各式各樣的設備需要中斷CPU的執行，像是網卡收發封包<strong>、</strong>鍵盤輸入<strong>、</strong>甚至是其他的CPU核心想要求某個特定的CPU核心處理某些事情等等，中斷控制器(interrupt controller)就是替CPU核心們管理這些的一個硬體設備，CPU可以藉由和中斷控制器溝通來彈性的管理各種系統上的中斷:</p>
<ul>
<li><p>開關各個中斷</p>
</li>
<li><p>調整各個中斷要送達哪一個CPU核心</p>
</li>
<li><p>決定各個中斷的優先級</p>
</li>
<li><p>觸發軟體中斷</p>
</li>
</ul>
<p>等等</p>
<p>另外，在處理中斷時，CPU核心也要和中斷控制器進行溝通，以下是處理中斷時的一個典型步驟:</p>
<ol>
<li><p>中斷控制器感知到外界第21號設備要中斷CPU核心</p>
</li>
<li><p>中斷控制器觀察到21號設備先前被設定成要送達0號CPU核心</p>
</li>
<li><p>中斷控制器把”21”這個數字存入代表目前中斷的暫存器中 (這個暫存器在中斷控制器中，不是CPU暫存器)</p>
</li>
<li><p>中斷控制器藉由改變與CPU0的中斷針腳的電位通知CPU0有中斷到達</p>
</li>
<li><p>CPU0放下手邊工作，讀取中斷控制器代表目前中斷的暫存器，讀到21，了解第21號設備需要服務</p>
</li>
<li><p>CPU0處理21號中斷</p>
</li>
<li><p>完成之後，CPU0寫入另一個中斷控制器的暫存器(EOI)，來告知中斷控制器它已完成此次中斷的處理</p>
</li>
</ol>
<h2 id="Linux核心的中斷管理與資料結構"><a href="#Linux核心的中斷管理與資料結構" class="headerlink" title="Linux核心的中斷管理與資料結構"></a>Linux核心的中斷管理與資料結構</h2><h3 id="Linux-IRQ-number-Hardware-IRQ-number"><a href="#Linux-IRQ-number-Hardware-IRQ-number" class="headerlink" title="Linux IRQ number &amp; Hardware IRQ number"></a>Linux IRQ number &amp; Hardware IRQ number</h3><p>Linux在管理系統上的各式中斷時，會為每一個中斷分配一個屬於自己的IRQ號碼，許多人稱Linux IRQ number。該數字用於區分系統中所有的中斷，在<code>/proc/interrupts</code> 看到的中斷號碼就是Linux IRQ number。Hardware IRQ number則是另一個概念，中斷控制器在前面例子中的”21”號，就是hardware IRQ number，是CPU向中斷控制器詢問哪個中斷觸發了，所會得到的答案。</p>
<p>你可能會想問為什麼要有Linux IRQ number呢? 全部都用hardware IRQ number不好嗎?</p>
<p>答案是: 的確，如果能都使用hardware IRQ number的話最好，但是隨著電腦系統越來越複雜，有些系統會出現不只一個中斷控制器的情況，這樣子問題就很明顯，不同中斷控制器有可能有相同的hardware IRQ number，但是接到完全不同的設備。於是乎，Linux就設計了hardware IRQ number轉換到Linux IRQ number的機制: IRQ Domain。</p>
<h3 id="IRQ-Domain"><a href="#IRQ-Domain" class="headerlink" title="IRQ Domain"></a>IRQ Domain</h3><p>Domain在數學中的定義是:</p>
<blockquote>
<p>Domain，定義域，函數自變數所有可取值的集合。 —wikipedia</p>
</blockquote>
<p>而在這邊的意義就是一個hardware IRQ number → Linux IRQ number的轉換範疇，每一個中斷控制器會有一個屬於它的IRQ Domain，屬於該中斷控制器的hardware IRQ number就要使用該IRQ Domain來轉換成全局唯一的Linux IRQ number，藉此繼續處理該中斷。</p>
<p>實際轉換時，Linux提供兩種方式:</p>
<ol>
<li><p>radix tree: 使用hardware IRQ number lookup radix tree來得到Linux IRQ number (對radix tree不熟目前只能這樣講 :P)</p>
</li>
<li><p>array lookup: 以hardware IRQ number作為array index取得Linux IRQ number</p>
</li>
</ol>
<p>以下我會把轉換的資料結構叫做”revmap”。</p>
<p>中斷控制器的驅動可以從兩種方式自由選用其一，radix tree適合不連續的hardware IRQ numbers。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span>              <span class="comment">// 系統中各個irq_domain被串起來</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>;</span>   <span class="comment">// 該中斷控制器的callback functions</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> revmap_size;           <span class="comment">// revmap array的大小，0代表使用radix tree</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">revmap_tree</span>;</span> <span class="comment">// radix tree</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> __<span class="title">rcu</span> *<span class="title">revmap</span>[];</span>    <span class="comment">// array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IRQ-Desc-IRQ-Data-IRQ-Action-中斷處理函式們"><a href="#IRQ-Desc-IRQ-Data-IRQ-Action-中斷處理函式們" class="headerlink" title="IRQ Desc &amp; IRQ Data &amp; IRQ Action &amp; 中斷處理函式們"></a>IRQ Desc &amp; IRQ Data &amp; IRQ Action &amp; 中斷處理函式們</h3><p>在<code>irq_domain</code> 可以看到<code>revmap[]</code> 其實並不是單純存著Linux IRQ number (int)，而是<code>irq_data</code> 的位址。每一個中斷初始化時都會分配一個<code>irq_desc</code> 儲存這個中斷的metadata，而<code>irq_data</code> 是<code>irq_desc</code> 的一部分，一個中斷對應到一個<code>irq_desc</code> 和<code>irq_data</code> 。Linux IRQ number → Hardware IRQ number的轉換(<code>irq</code>, <code>hwirq</code>)，以及其中斷處理函式 (<code>handle_irq</code>)均可以在這裡找到。<code>irqaction</code> 則是<code>irq_desc</code>中的一個鏈表，每一個<code>irqaction</code> 都有一個handler(<code>irqaction→handler</code>)，存著該Linux IRQ number的中斷處理函式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> &#123;</span></span><br><span class="line">        u32                     mask;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            irq;            <span class="comment">// Linux IRQ number</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>           hwirq;          <span class="comment">// Hardware IRQ number</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>  *<span class="title">common</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>         *<span class="title">chip</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>       *<span class="title">domain</span>;</span>        <span class="comment">// 所屬的irq domain</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>         *<span class="title">parent_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">void</span>                    *chip_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>  <span class="title">irq_common_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>         <span class="title">irq_data</span>;</span>       <span class="comment">// the embedded irq_data</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __percpu   *kstat_irqs;</span><br><span class="line">        <span class="type">irq_flow_handler_t</span>      handle_irq;     <span class="comment">// 中斷處理函式</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>        *<span class="title">action</span>;</span>        <span class="comment">/* IRQ action list */</span></span><br><span class="line">        [...]</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">        <span class="type">irq_handler_t</span>           handler;        <span class="comment">// 中斷處理函式</span></span><br><span class="line">        <span class="type">void</span>                    *dev_id;</span><br><span class="line">        <span class="type">void</span> __percpu           *percpu_dev_id;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>        *<span class="title">next</span>;</span></span><br><span class="line">        <span class="type">irq_handler_t</span>           thread_fn;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>      *<span class="title">thread</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>        *<span class="title">secondary</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            irq;            <span class="comment">// Linux IRQ number</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            flags;</span><br><span class="line">        [...]</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>以下是這四個資料結構的連結方式:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│     irq<span class="emphasis">_domain     │</span></span><br><span class="line"><span class="emphasis">│                    │</span></span><br><span class="line"><span class="emphasis">│ revmap             │</span></span><br><span class="line"><span class="emphasis">│                    │</span></span><br><span class="line"><span class="emphasis">└─┬─┬────────────────┘</span></span><br><span class="line"><span class="emphasis">  │ │</span></span><br><span class="line"><span class="emphasis">  │ │           ┌───────────────┐   ┌─────────────┐   ┌─────────────┐</span></span><br><span class="line"><span class="emphasis">  │ └──────────►│   irq_</span>desc    │ ┌►│  irqaction  ├──►│  irqaction  │</span><br><span class="line">  │             │               │ │ └──────┬──────┘   └──────┬──────┘</span><br><span class="line">  │           ┌─┴────────────┐  │ │        │                 │</span><br><span class="line">  │           │   irq<span class="emphasis">_desc   │  │ │        ▼                 ▼</span></span><br><span class="line"><span class="emphasis">  │           │              │  │ │   ┌─────────┐       ┌─────────┐</span></span><br><span class="line"><span class="emphasis">  │           │ ┌──────────┐ │  │ │   │ handler │       │ handler │</span></span><br><span class="line"><span class="emphasis">  └──────────►│ │ irq_</span>data │ │  ├─┘   └─────────┘       └─────────┘</span><br><span class="line"><span class="code">              │ └──────────┘ ├──┘</span></span><br><span class="line"><span class="code">              │              │   ┌─────────────┐   ┌─────────────┐</span></span><br><span class="line"><span class="code">              │              ├──►│  irqaction  ├──►│  irqaction  │</span></span><br><span class="line"><span class="code">              └──────────────┘   └──────┬──────┘   └──────┬──────┘</span></span><br><span class="line"><span class="code">                                        │                 │</span></span><br><span class="line"><span class="code">                                        ▼                 ▼</span></span><br><span class="line"><span class="code">                                   ┌─────────┐       ┌─────────┐</span></span><br><span class="line"><span class="code">                                   │ handler │       │ handler │</span></span><br><span class="line"><span class="code">                                   └─────────┘       └─────────┘</span></span><br></pre></td></tr></table></figure>

<p>對於一個中斷來說，已經有<code>irq_desc→handle_irq</code> 了，為什麼還要有<code>irqaction</code> 鏈表中的handler?</p>
<p><code>irq_desc→handle_irq</code> 主要負責該IRQ的flow control和中斷控制器互動，例如mask unmask, ACK(通知控制器該中斷已正被處理), EOI(通知控制器中斷已完成處理)等等操作，而<code>irqaction→handler</code> 則是device specific的中斷處理，例如和網卡<strong>、</strong>硬碟互動等等。通常<code>irqaction→handler</code> 由各設備的驅動程式提供，<code>irq_desc→handle_irq</code> 則是由中斷控制器驅動設置，基本上是<code>handle_*</code> 家族函式，如</p>
<ul>
<li><p><code>handle_level_irq</code></p>
</li>
<li><p><code>handle_edge_irq</code></p>
</li>
<li><p><code>handle_fasteoi_irq</code></p>
</li>
<li><p><code>handle_percpu_devid_irq</code></p>
</li>
</ul>
<p>有人會把上述<code>irq_desc→handle_irq</code> 叫做這個IRQ的high level irq event handler。</p>
<p>除此之外，中斷控制器初始化時還須提供一個函式，來執行從中斷控制器讀取hardware IRQ number，利用irq domain定位正確<code>irq_desc</code> 來處理中斷等等更加底層的操作。在我們的ARM64例子中，設定的方式是GICv2初始化時會讓<code>handle_arch_irq</code>這個函式指標指到<code>gic_handle_irq</code> 來處理中斷。</p>
<h2 id="Linux中斷處理流程"><a href="#Linux中斷處理流程" class="headerlink" title="Linux中斷處理流程"></a>Linux中斷處理流程</h2><p>換一個方式，利用簡化的Linux中斷處理流程來理解前面介紹的各個資料結構和各個中斷處理函式:</p>
<ol>
<li><p>中斷發生，exception vector進行中斷現場保存，呼叫<code>handle_arch_irq</code> (function pointer) 指向的函式</p>
</li>
<li><p>該函式讀取中斷控制器的暫存器得知hardware IRQ number，使用中斷控制器對應的<code>irq_domain</code>進行hardware IRQ number → Linux IRQ number轉換，並得到<code>irq_desc</code></p>
</li>
<li><p>呼叫<code>irq_desc→handle_irq</code> (high level irq event handler)</p>
</li>
<li><p>high level irq event handler依次呼叫<code>irq_desc-&gt;action</code> 鏈表中的<code>handler</code></p>
</li>
</ol>
<p>Linux在能夠處理中斷之前，要把這3個不同層級的handlers function pointer設定好:</p>
<h3 id="全局的handle-arch-irq"><a href="#全局的handle-arch-irq" class="headerlink" title="全局的handle_arch_irq"></a>全局的<code>handle_arch_irq</code></h3><p>這個函式由最底層負責中斷現場保存的程式呼叫，通常由中斷控制器初始化程式設定，所有中斷處理都會呼叫(全局唯一)</p>
<h3 id="irq-desc→handle-irq"><a href="#irq-desc→handle-irq" class="headerlink" title="irq_desc→handle_irq"></a><code>irq_desc→handle_irq</code></h3><p>此函式負責該中斷的flow control，ACK, EOI, etc. 一個中斷一個，也稱high level event handler</p>
<h3 id="irqaction→handler"><a href="#irqaction→handler" class="headerlink" title="irqaction→handler"></a><code>irqaction→handler</code></h3><p><code>irq_desc→handle_irq</code> 會依次呼叫<code>irq_desc</code> 中<code>irqaction</code> 鏈表中的各個<code>handler</code> (一個中斷可以有多個)</p>
<h2 id="實例-GICv2建立IPI處理流程"><a href="#實例-GICv2建立IPI處理流程" class="headerlink" title="實例: GICv2建立IPI處理流程"></a>實例: GICv2建立IPI處理流程</h2><p>經過上面的描述之後我們來觀察GICv2本身和IPI(inter processor interrupt)中斷是如何初始化的，以下每個小節介紹中斷處理機制建立過程的一部分，各個小節按照執行順序編排，而因為有些函式做很多事情，所以會有些函式重複出現。</p>
<blockquote>
<p>小提示: 以下列出的函式數量不少，實際把call graph畫出來會讓理解方便許多</p>
</blockquote>
<h3 id="1-設置全局irq-handler-handle-arch-irq"><a href="#1-設置全局irq-handler-handle-arch-irq" class="headerlink" title="1. 設置全局irq handler handle_arch_irq"></a>1. 設置全局irq handler <code>handle_arch_irq</code></h3><p><code>start_kernel</code> → <code>init_IRQ</code> → <code>irqchip_init</code> → <code>of_irq_init</code></p>
<p><code>of_irq_init</code> 呼叫GICv2初始化的callback <code>gic_of_init</code> → <code>__gic_init_bases</code> → <code>set_irq_handler</code> 來設置全局irq handler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init __gic_init_bases(<span class="keyword">struct</span> gic_chip_data *gic,</span><br><span class="line">                                   <span class="keyword">struct</span> fwnode_handle *handle)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gic == &amp;gic_data[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Initialize the CPU interface map to all CPUs.</span></span><br><span class="line"><span class="comment">                 * It will be refined as each CPU probes its ID.</span></span><br><span class="line"><span class="comment">                 * This is only necessary for the primary GIC.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_GIC_CPU_IF; i++)</span><br><span class="line">                        gic_cpu_map[i] = <span class="number">0xff</span>;</span><br><span class="line">                <span class="comment">// 設置全局handle_arch_irq函式指標</span></span><br><span class="line">                set_handle_irq(gic_handle_irq);</span><br><span class="line">                <span class="keyword">if</span> (static_branch_likely(&amp;supports_deactivate_key))</span><br><span class="line">                        pr_info(<span class="string">&quot;GIC: Using split EOI/Deactivate mode\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ret = gic_init_bases(gic, handle);</span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">set_handle_irq</span><span class="params">(<span class="type">void</span> (*handle_irq)(<span class="keyword">struct</span> pt_regs *))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_arch_irq != default_handle_irq)</span><br><span class="line">                <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        <span class="comment">// 指定全局函式指標handle_arch_irq為gic_handle_irq</span></span><br><span class="line">        handle_arch_irq = handle_irq;</span><br><span class="line">        pr_info(<span class="string">&quot;Root IRQ handler: %ps\n&quot;</span>, handle_irq);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-allocate屬於此中斷控制器的irq-domain-與revmap"><a href="#2-allocate屬於此中斷控制器的irq-domain-與revmap" class="headerlink" title="2. allocate屬於此中斷控制器的irq_domain 與revmap"></a>2. allocate屬於此中斷控制器的<code>irq_domain</code> 與revmap</h3><p>同樣在<code>__gic_init_bases</code> ，<code>__gic_init_bases</code> → <code>gic_init_bases</code> → <code>irq_domain_create_linear</code> → <code>__irq_domain_add</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_init_bases</span><span class="params">(<span class="keyword">struct</span> gic_chip_data *gic,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> fwnode_handle *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> gic_irqs, ret;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handle) &#123;           <span class="comment">/* DT/ACPI */</span></span><br><span class="line">                <span class="comment">// 為此GIC allocate irq_domain，還有負責轉換的revmap</span></span><br><span class="line">                gic-&gt;domain = irq_domain_create_linear(handle, gic_irqs,</span><br><span class="line">                                                       &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">                                                       gic);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">/* Legacy support */</span></span><br><span class="line">                [...]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> irq_domain *<span class="title function_">irq_domain_create_linear</span><span class="params">(<span class="keyword">struct</span> fwnode_handle *fwnode,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                                         <span class="type">const</span> <span class="keyword">struct</span> irq_domain_ops *ops,</span></span><br><span class="line"><span class="params">                                         <span class="type">void</span> *host_data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> __irq_domain_add(fwnode, size, size, <span class="number">0</span>, ops, host_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *__<span class="title">irq_domain_add</span>(<span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">irq_hw_number_t</span> <span class="title">hwirq_max</span>, <span class="title">int</span> <span class="title">direct_max</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">void</span> *<span class="title">host_data</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqchip_fwid</span> *<span class="title">fwid</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="type">atomic_t</span> unknown_domains;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// 為此GIC allocate irq_domain，還有負責傳換的revmap</span></span><br><span class="line">        <span class="comment">// size == 0 代表使用 radix tree轉換， size != 0代表使用array轉換</span></span><br><span class="line">        <span class="comment">// GICv2 使用array轉換</span></span><br><span class="line">        domain = kzalloc_node(struct_size(domain, revmap, size),</span><br><span class="line">                              GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));</span><br><span class="line">        <span class="keyword">if</span> (!domain)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fill structure */</span></span><br><span class="line">        INIT_RADIX_TREE(&amp;domain-&gt;revmap_tree, GFP_KERNEL);</span><br><span class="line">        mutex_init(&amp;domain-&gt;revmap_mutex);</span><br><span class="line">        domain-&gt;ops = ops;</span><br><span class="line">        domain-&gt;host_data = host_data;</span><br><span class="line">        domain-&gt;hwirq_max = hwirq_max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (direct_max) &#123;</span><br><span class="line">                domain-&gt;flags |= IRQ_DOMAIN_FLAG_NO_MAP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// size == 0 代表使用 radix tree， size != 0代表使用array轉換</span></span><br><span class="line">        domain-&gt;revmap_size = size;</span><br><span class="line">        [...]</span><br><span class="line">        mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">        debugfs_add_domain_dir(domain);</span><br><span class="line">        <span class="comment">// 把這個irq_domain掛入全局irq_domain_list中</span></span><br><span class="line">        list_add(&amp;domain-&gt;link, &amp;irq_domain_list);</span><br><span class="line">        mutex_unlock(&amp;irq_domain_mutex);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-利用IPI的hardware-IRQ-number來allocate對應數量的Linux-IRQ-number和-irq-desc"><a href="#3-利用IPI的hardware-IRQ-number來allocate對應數量的Linux-IRQ-number和-irq-desc" class="headerlink" title="3. 利用IPI的hardware IRQ number來allocate對應數量的Linux IRQ number和 irq_desc"></a>3. 利用IPI的hardware IRQ number來allocate對應數量的Linux IRQ number和 <code>irq_desc</code></h3><p><code>__gic_init_bases</code> → <code>gic_smp_init</code> → <code>__irq_domain_alloc_irqs</code> → <code>irq_domain_alloc_descs</code> → <code>__irq_alloc_descs</code> → <code>alloc_descs</code> → <code>alloc_desc</code> &amp; <code>irq_insert_desc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __init <span class="type">void</span> <span class="title function_">gic_smp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> <span class="title">sgi_fwspec</span> =</span> &#123;</span><br><span class="line">                .fwnode         = gic_data[<span class="number">0</span>].domain-&gt;fwnode,</span><br><span class="line">                .param_count    = <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> base_sgi;</span><br><span class="line"></span><br><span class="line">        cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING,</span><br><span class="line">                                  <span class="string">&quot;irqchip/arm/gic:starting&quot;</span>,</span><br><span class="line">                                  gic_starting_cpu, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 剛才allocate的domain的位址會被記錄在gic_data[0].domain中，所以傳入它</span></span><br><span class="line">        <span class="comment">// -1代表不特別指定要使用的Linux IRQ number</span></span><br><span class="line">        <span class="comment">// 8代表要allocate 8個Linux IRQ number &amp; irq_desc</span></span><br><span class="line">        <span class="comment">// 猜測是因為GICv2最多只允許8個CPU，所以allocate 8個IPI中斷</span></span><br><span class="line">        base_sgi = __irq_domain_alloc_irqs(gic_data[<span class="number">0</span>].domain, <span class="number">-1</span>, <span class="number">8</span>,</span><br><span class="line">                                           NUMA_NO_NODE, &amp;sgi_fwspec,</span><br><span class="line">                                           <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (WARN_ON(base_sgi &lt;= <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        set_smp_ipi_range(base_sgi, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __irq_domain_alloc_irqs(<span class="keyword">struct</span> irq_domain *domain, <span class="type">int</span> irq_base,</span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">int</span> node, <span class="type">void</span> *arg,</span><br><span class="line">                            <span class="type">bool</span> <span class="built_in">realloc</span>, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, ret, virq;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">realloc</span> &amp;&amp; irq_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                virq = irq_base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 呼叫更底層的函式</span></span><br><span class="line">                virq = irq_domain_alloc_descs(irq_base, nr_irqs, <span class="number">0</span>, node,</span><br><span class="line">                                              affinity);</span><br><span class="line">                <span class="keyword">if</span> (virq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_debug(<span class="string">&quot;cannot allocate IRQ(base %d, count %d)\n&quot;</span>,</span><br><span class="line">                                 irq_base, nr_irqs);</span><br><span class="line">                        <span class="keyword">return</span> virq;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_domain_alloc_descs</span><span class="params">(<span class="type">int</span> virq, <span class="type">unsigned</span> <span class="type">int</span> cnt, <span class="type">irq_hw_number_t</span> hwirq,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> node, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span></span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line">                <span class="comment">// 呼叫更底層的函式</span></span><br><span class="line">                virq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,</span><br><span class="line">                                         affinity);</span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __ref</span><br><span class="line">__irq_alloc_descs(<span class="type">int</span> irq, <span class="type">unsigned</span> <span class="type">int</span> from, <span class="type">unsigned</span> <span class="type">int</span> cnt, <span class="type">int</span> node,</span><br><span class="line">                  <span class="keyword">struct</span> module *owner, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> start, ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cnt)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (irq &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (from &gt; irq)</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                from = irq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * For interrupts which are freely allocated the</span></span><br><span class="line"><span class="comment">                 * architecture can force a lower bound to the @from</span></span><br><span class="line"><span class="comment">                 * argument. x86 uses this to exclude the GSI space.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                from = arch_dynirq_lower_bound(from);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;sparse_irq_lock);</span><br><span class="line">        <span class="comment">// allocated_irqs是一個全局bitmap，每個index記錄該Linux IRQ number是否</span></span><br><span class="line">        <span class="comment">// 已被使用</span></span><br><span class="line">        <span class="comment">// e.g. allocated_irqs[10] == 1 代表Linux IRQ number 10已被使用</span></span><br><span class="line">        <span class="comment">// 所以這邊找一塊連續尚未被使用的Linux IRQ numbers</span></span><br><span class="line">        start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,</span><br><span class="line">                                           from, cnt, <span class="number">0</span>);</span><br><span class="line">        ret = -EEXIST;</span><br><span class="line">        <span class="keyword">if</span> (irq &gt;=<span class="number">0</span> &amp;&amp; start != irq)</span><br><span class="line">                <span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start + cnt &gt; nr_irqs) &#123;</span><br><span class="line">                ret = irq_expand_nr_irqs(start + cnt);</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br><span class="line">                        <span class="keyword">goto</span> unlock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 呼叫更底層的函式</span></span><br><span class="line">        ret = alloc_descs(start, cnt, node, affinity, owner);</span><br><span class="line">unlock:</span><br><span class="line">        mutex_unlock(&amp;sparse_irq_lock);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_descs</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> cnt, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> module *owner)</span></span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// 每個迴圈allocate單一一個irq_desc</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">mask</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                [...]</span><br><span class="line">                <span class="comment">// 真正呼叫kzmalloc allocate irq_desc並填入fields</span></span><br><span class="line">                <span class="comment">// (不特別展開了)</span></span><br><span class="line">                desc = alloc_desc(start + i, node, flags, mask, owner);</span><br><span class="line">                <span class="keyword">if</span> (!desc)</span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                <span class="comment">// 將剛allocate出的irq_desc用對應的Linux IRQ number插入全局</span></span><br><span class="line">                <span class="comment">// radix tree irq_desc_tree (不要和revmap搞混了)</span></span><br><span class="line">                irq_insert_desc(start + i, desc);</span><br><span class="line">                [...]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把我們開始使用的Linux IRQ numbers在bitmap中設成1</span></span><br><span class="line">        bitmap_set(allocated_irqs, start, cnt);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">irq_insert_desc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">        radix_tree_insert(&amp;irq_desc_tree, irq, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用GICv2的callback設置IPI的irq-desc→handle-irq"><a href="#4-使用GICv2的callback設置IPI的irq-desc→handle-irq" class="headerlink" title="4. 使用GICv2的callback設置IPI的irq_desc→handle_irq"></a>4. 使用GICv2的callback設置IPI的<code>irq_desc→handle_irq</code></h3><p>剛才3.只是allocate，還沒設置<code>irq_desc→handle_irq</code>中斷處理函式</p>
<p><code>__irq_domain_alloc_descs</code> → <code>irq_domain_alloc_irqs_hierarchy</code> → <code>gic_irq_domain_alloc</code> → <code>gic_irq_domain_map</code> → <code>irq_domain_set_info</code> → <code>__irq_set_handler</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __irq_domain_alloc_irqs(<span class="keyword">struct</span> irq_domain *domain, <span class="type">int</span> irq_base,</span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">int</span> node, <span class="type">void</span> *arg,</span><br><span class="line">                            <span class="type">bool</span> <span class="built_in">realloc</span>, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">realloc</span> &amp;&amp; irq_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                virq = irq_base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 剛剛3.提到的allocate irq_desc &amp; Linux IRQ numbers</span></span><br><span class="line">                virq = irq_domain_alloc_descs(irq_base, nr_irqs, <span class="number">0</span>, node,</span><br><span class="line">                                              affinity);</span><br><span class="line">                <span class="keyword">if</span> (virq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_debug(<span class="string">&quot;cannot allocate IRQ(base %d, count %d)\n&quot;</span>,</span><br><span class="line">                                 irq_base, nr_irqs);</span><br><span class="line">                        <span class="keyword">return</span> virq;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">        <span class="comment">// 繼續處理</span></span><br><span class="line">        ret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_domain_alloc_irqs_hierarchy</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">int</span> irq_base,</span></span><br><span class="line"><span class="params">                                    <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!domain-&gt;ops-&gt;alloc) &#123;</span><br><span class="line">                pr_debug(<span class="string">&quot;domain-&gt;ops-&gt;alloc() is NULL\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接呼叫irq_domain的alloc callback來繼續執行，</span></span><br><span class="line">        <span class="comment">// 會接到gic_irq_domain_alloc</span></span><br><span class="line">        <span class="comment">// 有興趣的讀者可以自行尋找domain-&gt;ops在哪裡被設置的</span></span><br><span class="line">        <span class="comment">// 提示: 這篇裡面找的到</span></span><br><span class="line">        <span class="keyword">return</span> domain-&gt;ops-&gt;alloc(domain, irq_base, nr_irqs, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, ret;</span><br><span class="line">        <span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> *<span class="title">fwspec</span> =</span> arg;</span><br><span class="line">        <span class="comment">// 取得hardware IRQ number</span></span><br><span class="line">        <span class="comment">// 以我們的例子GIC的IPI hardware IRQ number是從0~15，但在這邊我們</span></span><br><span class="line">        <span class="comment">// 只使用8個，所以是0~7</span></span><br><span class="line">        ret = gic_irq_domain_translate(domain, fwspec, &amp;hwirq, &amp;type);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">// 每一次迴圈幫一個IRQ設置其irq_desc-&gt;handle_irq</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++) &#123;</span><br><span class="line">                ret = gic_irq_domain_map(domain, virq + i, hwirq + i);</span><br><span class="line">                <span class="keyword">if</span> (ret)</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                                <span class="type">irq_hw_number_t</span> hw)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> d-&gt;host_data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">irqd</span> =</span> irq_desc_get_irq_data(irq_to_desc(irq));</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">        chip = (static_branch_likely(&amp;supports_deactivate_key) &amp;&amp;</span><br><span class="line">                gic == &amp;gic_data[<span class="number">0</span>]) ? &amp;gic_chip_mode1 : &amp;gic_chip;</span><br><span class="line">        <span class="comment">// GICv2 hardware IRQ number 0-31是banked per PE，所以這樣區分2個case</span></span><br><span class="line">        <span class="comment">// 我們的case是0~7 也就是0 ... 31</span></span><br><span class="line">        <span class="keyword">switch</span> (hw) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">31</span>:</span><br><span class="line">                irq_set_percpu_devid(irq);</span><br><span class="line">                <span class="comment">// 將handle_percpu_devid_irq這個high level IRQ event handler</span></span><br><span class="line">                <span class="comment">// 設定成該irq_desc-&gt;handle_irq</span></span><br><span class="line">                irq_domain_set_info(d, irq, hw, chip, d-&gt;host_data,</span><br><span class="line">                                    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                irq_domain_set_info(d, irq, hw, chip, d-&gt;host_data,</span><br><span class="line">                                    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                irq_set_probe(irq);</span><br><span class="line">                irqd_set_single_target(irqd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Prevents SW retriggers which mess up the ACK/EOI ordering */</span></span><br><span class="line">        irqd_set_handle_enforce_irqctx(irqd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_domain_set_info</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">                         <span class="type">irq_hw_number_t</span> hwirq, <span class="type">const</span> <span class="keyword">struct</span> irq_chip *chip,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span> *chip_data, <span class="type">irq_flow_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span> *handler_data, <span class="type">const</span> <span class="type">char</span> *handler_name)</span></span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// 此函式真正設定irq_desc-&gt;handle_irq </span></span><br><span class="line">        <span class="comment">// (desc-&gt;handle_irq = handler)</span></span><br><span class="line">        <span class="comment">// 不過也做了許多其他複雜的操作，所以不展開</span></span><br><span class="line">        __irq_set_handler(virq, handler, <span class="number">0</span>, handler_name);</span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-建立hardware-IRQ-number-→-Linux-IRQ-number的轉換revmap"><a href="#5-建立hardware-IRQ-number-→-Linux-IRQ-number的轉換revmap" class="headerlink" title="5. 建立hardware IRQ number → Linux IRQ number的轉換revmap"></a>5. 建立hardware IRQ number → Linux IRQ number的轉換revmap</h3><p><code>__irq_domain_alloc_descs</code> → <code>irq_domain_insert_irq</code> → <code>irq_domain_set_mapping</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __irq_domain_alloc_irqs(<span class="keyword">struct</span> irq_domain *domain, <span class="type">int</span> irq_base,</span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">int</span> node, <span class="type">void</span> *arg,</span><br><span class="line">                            <span class="type">bool</span> <span class="built_in">realloc</span>, <span class="type">const</span> <span class="keyword">struct</span> irq_affinity_desc *affinity)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">realloc</span> &amp;&amp; irq_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                virq = irq_base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 剛剛3.提到的allocate irq_desc &amp; Linux IRQ numbers</span></span><br><span class="line">                virq = irq_domain_alloc_descs(irq_base, nr_irqs, <span class="number">0</span>, node,</span><br><span class="line">                                              affinity);</span><br><span class="line">                <span class="keyword">if</span> (virq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        pr_debug(<span class="string">&quot;cannot allocate IRQ(base %d, count %d)\n&quot;</span>,</span><br><span class="line">                                 irq_base, nr_irqs);</span><br><span class="line">                        <span class="keyword">return</span> virq;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;irq_domain_mutex);</span><br><span class="line">        <span class="comment">// 剛剛4.提到的設置irq_desc-&gt;handle_irq</span></span><br><span class="line">        ret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// 每個迴圈為一個IRQ設置其revmap</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++)</span><br><span class="line">                irq_domain_insert_irq(virq + i);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">irq_domain_insert_irq</span><span class="params">(<span class="type">int</span> virq)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">data</span>;</span></span><br><span class="line">        <span class="comment">// 此迴圈&quot;應該&quot;與chained interrupt controllers有關，在我們的例子可以假設</span></span><br><span class="line">        <span class="comment">// 只跑一次</span></span><br><span class="line">        <span class="keyword">for</span> (data = irq_get_irq_data(virq); data; data = data-&gt;parent_data) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span> =</span> data-&gt;domain;</span><br><span class="line"></span><br><span class="line">                domain-&gt;mapcount++;</span><br><span class="line">                <span class="comment">// 繼續處理</span></span><br><span class="line">                irq_domain_set_mapping(domain, data-&gt;hwirq, data);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* If not already assigned, give the domain the chip&#x27;s name */</span></span><br><span class="line">                <span class="keyword">if</span> (!domain-&gt;name &amp;&amp; data-&gt;chip)</span><br><span class="line">                        domain-&gt;name = data-&gt;chip-&gt;name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        irq_clear_status_flags(virq, IRQ_NOREQUEST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">irq_domain_set_mapping</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">                                   <span class="type">irq_hw_number_t</span> hwirq,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> irq_data *irq_data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (irq_domain_is_nomap(domain))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;domain-&gt;revmap_mutex);</span><br><span class="line">        <span class="comment">// 使用array還是radix tree?</span></span><br><span class="line">        <span class="comment">// array (GICv2的case)</span></span><br><span class="line">        <span class="keyword">if</span> (hwirq &lt; domain-&gt;revmap_size)</span><br><span class="line">                <span class="comment">// 把hardware IRQ number當作index，填入該IRQ的irq_data即可</span></span><br><span class="line">                rcu_assign_pointer(domain-&gt;revmap[hwirq], irq_data);</span><br><span class="line">        <span class="comment">// radix tree</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                radix_tree_insert(&amp;domain-&gt;revmap_tree, hwirq, irq_data);</span><br><span class="line">        mutex_unlock(&amp;domain-&gt;revmap_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-使用request-percpu-irq-allocate-irqaction-並安裝到irq-desc→action-鏈表中"><a href="#6-使用request-percpu-irq-allocate-irqaction-並安裝到irq-desc→action-鏈表中" class="headerlink" title="6. 使用request_percpu_irq allocate irqaction 並安裝到irq_desc→action 鏈表中"></a>6. 使用<code>request_percpu_irq</code> allocate <code>irqaction</code> 並安裝到<code>irq_desc→action</code> 鏈表中</h3><p>接著，<code>gic_smp_init</code> → <code>set_smp_ipi_range</code> 呼叫<code>request_percpu_irq</code> 來allocate <code>irqaction</code> 並安裝到<code>irq_desc→action</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">set_smp_ipi_range</span><span class="params">(<span class="type">int</span> ipi_base, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        WARN_ON(n &lt; NR_IPI);</span><br><span class="line">        nr_ipi = min(n, NR_IPI);</span><br><span class="line">        <span class="comment">// 每一個迴圈設定一個IRQ的irqaction</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_ipi; i++) &#123;</span><br><span class="line">                <span class="type">int</span> err;</span><br><span class="line">                <span class="comment">// 將ipi_handler這個函式設定到irqaction-&gt;handler並安裝到</span></span><br><span class="line">                <span class="comment">// irq_desc-&gt;action list</span></span><br><span class="line">                err = request_percpu_irq(ipi_base + i, ipi_handler,</span><br><span class="line">                                         <span class="string">&quot;IPI&quot;</span>, &amp;cpu_number);</span><br><span class="line">                WARN_ON(err);</span><br><span class="line"></span><br><span class="line">                ipi_desc[i] = irq_to_desc(ipi_base + i);</span><br><span class="line">                irq_set_status_flags(ipi_base + i, IRQ_HIDDEN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_percpu_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> __percpu *percpu_dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> __request_percpu_irq(irq, handler, <span class="number">0</span>,</span><br><span class="line">                                    devname, percpu_dev_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __request_percpu_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span><br><span class="line">                         <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *devname,</span><br><span class="line">                         <span class="type">void</span> __percpu *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        desc = irq_to_desc(irq);</span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// allocate一個irqaction出來</span></span><br><span class="line">        action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!action)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="comment">// 設定其action-&gt;handler (ipi_handler)</span></span><br><span class="line">        action-&gt;handler = handler;</span><br><span class="line">        action-&gt;flags = flags | IRQF_PERCPU | IRQF_NO_SUSPEND;</span><br><span class="line">        action-&gt;name = devname;</span><br><span class="line">        action-&gt;percpu_dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// 巨大的IRQ中斷子系統函式，做的其中一件</span></span><br><span class="line">        <span class="comment">// 重要的事就是將irq_desc-&gt;action接上這裡新allocate的irqaction</span></span><br><span class="line">        retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未提到的中斷相關概念們"><a href="#未提到的中斷相關概念們" class="headerlink" title="未提到的中斷相關概念們"></a>未提到的中斷相關概念們</h2><ul>
<li><p>threaded IRQs</p>
</li>
<li><p>chained interrupt controllers</p>
</li>
<li><p>nested interrupt controllers</p>
</li>
<li><p>shared IRQs</p>
</li>
<li><p>spurious interrupts</p>
</li>
<li><p>softirqs</p>
</li>
<li><p>tasklets</p>
</li>
<li><p>workqueues</p>
</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/sort/irq_subsystem">中断子系统 - 蜗窝科技 (</a><a href="wowotech.net">wowotech.net</a><a target="_blank" rel="noopener" href="http://www.wowotech.net/sort/irq_subsystem">)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://youtu.be/LOCsN3V1ECE?si=piviVroOdJ_UVgnl">Understanding Linux Interrupt Subsystem - Priya Dixit, Samsung Semiconductor India Research</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://youtu.be/YE8cRHVIM4E?si=ENdH1X5EEDCMxCwI">How Dealing with Modern Interrupt Architectures can Affect Your Sanity</a></p>
</li>
</ul>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%89%8D%E8%A8%80"><span class="top-box-text">前言</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E4%B8%AD%E6%96%B7%E6%A5%B5%E7%B0%A1%E4%BB%8B%E7%B4%B9"><span class="top-box-text">作業系統中斷極簡介紹</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux%E6%A0%B8%E5%BF%83%E7%9A%84%E4%B8%AD%E6%96%B7%E7%AE%A1%E7%90%86%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B"><span class="top-box-text">Linux核心的中斷管理與資料結構</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Linux-IRQ-number-Hardware-IRQ-number"><span class="top-box-text">Linux IRQ number &amp; Hardware IRQ number</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IRQ-Domain"><span class="top-box-text">IRQ Domain</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#IRQ-Desc-IRQ-Data-IRQ-Action-%E4%B8%AD%E6%96%B7%E8%99%95%E7%90%86%E5%87%BD%E5%BC%8F%E5%80%91"><span class="top-box-text">IRQ Desc &amp; IRQ Data &amp; IRQ Action &amp; 中斷處理函式們</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Linux%E4%B8%AD%E6%96%B7%E8%99%95%E7%90%86%E6%B5%81%E7%A8%8B"><span class="top-box-text">Linux中斷處理流程</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%85%A8%E5%B1%80%E7%9A%84handle-arch-irq"><span class="top-box-text">全局的handle_arch_irq</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#irq-desc%E2%86%92handle-irq"><span class="top-box-text">irq_desc→handle_irq</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#irqaction%E2%86%92handler"><span class="top-box-text">irqaction→handler</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AF%A6%E4%BE%8B-GICv2%E5%BB%BA%E7%AB%8BIPI%E8%99%95%E7%90%86%E6%B5%81%E7%A8%8B"><span class="top-box-text">實例: GICv2建立IPI處理流程</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-%E8%A8%AD%E7%BD%AE%E5%85%A8%E5%B1%80irq-handler-handle-arch-irq"><span class="top-box-text">1. 設置全局irq handler handle_arch_irq</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-allocate%E5%B1%AC%E6%96%BC%E6%AD%A4%E4%B8%AD%E6%96%B7%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84irq-domain-%E8%88%87revmap"><span class="top-box-text">2. allocate屬於此中斷控制器的irq_domain 與revmap</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-%E5%88%A9%E7%94%A8IPI%E7%9A%84hardware-IRQ-number%E4%BE%86allocate%E5%B0%8D%E6%87%89%E6%95%B8%E9%87%8F%E7%9A%84Linux-IRQ-number%E5%92%8C-irq-desc"><span class="top-box-text">3. 利用IPI的hardware IRQ number來allocate對應數量的Linux IRQ number和 irq_desc</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-%E4%BD%BF%E7%94%A8GICv2%E7%9A%84callback%E8%A8%AD%E7%BD%AEIPI%E7%9A%84irq-desc%E2%86%92handle-irq"><span class="top-box-text">4. 使用GICv2的callback設置IPI的irq_desc→handle_irq</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#5-%E5%BB%BA%E7%AB%8Bhardware-IRQ-number-%E2%86%92-Linux-IRQ-number%E7%9A%84%E8%BD%89%E6%8F%9Brevmap"><span class="top-box-text">5. 建立hardware IRQ number → Linux IRQ number的轉換revmap</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#6-%E4%BD%BF%E7%94%A8request-percpu-irq-allocate-irqaction-%E4%B8%A6%E5%AE%89%E8%A3%9D%E5%88%B0irq-desc%E2%86%92action-%E9%8F%88%E8%A1%A8%E4%B8%AD"><span class="top-box-text">6. 使用request_percpu_irq allocate irqaction 並安裝到irq_desc→action 鏈表中</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%9C%AA%E6%8F%90%E5%88%B0%E7%9A%84%E4%B8%AD%E6%96%B7%E7%9B%B8%E9%97%9C%E6%A6%82%E5%BF%B5%E5%80%91"><span class="top-box-text">未提到的中斷相關概念們</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99"><span class="top-box-text">參考資料</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/kaslr2_en/">
          <h3 class="post-title">
            Next: Linux ARM64 KASLR Implementation(2): Linear Mapping Randomization
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>



    <script>window.is_post = true;</script>


<script src="/js/main.js"></script>





    </div>
  </body>
</html>

